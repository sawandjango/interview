"""
LeetCode Problem #133: Clone Graph

Difficulty: Medium
Topics: Graph, DFS, BFS, Hash Table
Companies: Facebook, Amazon, Google, Microsoft, Uber

================================================================================
                    ğŸ“š QUICK REFERENCE - WHAT'S IN THIS FILE
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ğŸ“– TABLE OF CONTENTS                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ #    â”‚ SECTION                              â”‚ WHAT YOU'LL LEARN             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1    â”‚ ğŸ¯ PROBLEM UNDERSTANDING             â”‚ â€¢ What is being asked?        â”‚
â”‚      â”‚                                      â”‚ â€¢ Real-world analogies        â”‚
â”‚      â”‚                                      â”‚ â€¢ Visual examples             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2    â”‚ ğŸ§  KEY INSIGHTS TO REMEMBER          â”‚ â€¢ Main challenge              â”‚
â”‚      â”‚                                      â”‚ â€¢ Base cases to handle        â”‚
â”‚      â”‚                                      â”‚ â€¢ Pattern recognition         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3    â”‚ ğŸš€ HOW TO APPROACH THIS PROBLEM      â”‚ â€¢ Step-by-step process        â”‚
â”‚      â”‚                                      â”‚ â€¢ Decision tree               â”‚
â”‚      â”‚                                      â”‚ â€¢ Interview scenarios         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4    â”‚ ğŸ’¡ SOLUTION 1: DFS with HashMap â­    â”‚ â€¢ WHY choose? (Pros/Cons)     â”‚
â”‚      â”‚    (RECOMMENDED)                     â”‚ â€¢ WHEN to use?                â”‚
â”‚      â”‚                                      â”‚ â€¢ Step-by-step walkthrough    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 5    â”‚ ğŸ’¡ SOLUTION 2: BFS with Queue        â”‚ â€¢ WHY choose? (Pros/Cons)     â”‚
â”‚      â”‚    (Alternative)                     â”‚ â€¢ WHEN to use?                â”‚
â”‚      â”‚                                      â”‚ â€¢ Comparison with Solution 1  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 6    â”‚ ğŸ’» IMPLEMENTATION                    â”‚ â€¢ Clean, commented code       â”‚
â”‚      â”‚                                      â”‚ â€¢ Both solutions              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 7    â”‚ ğŸ§ª TEST CASES                        â”‚ â€¢ Comprehensive tests         â”‚
â”‚      â”‚                                      â”‚ â€¢ Edge cases covered          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 8    â”‚ ğŸ“ LEARNING SUMMARY                  â”‚ â€¢ Key takeaways               â”‚
â”‚      â”‚                                      â”‚ â€¢ Memory tricks               â”‚
â”‚      â”‚                                      â”‚ â€¢ Common mistakes             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 9    â”‚ ğŸ”— RELATED PROBLEMS                  â”‚ â€¢ Similar problems            â”‚
â”‚      â”‚                                      â”‚ â€¢ Pattern recognition         â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ğŸ¯ MEMORY CHEAT SHEET                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ANALOGY          â”‚ "Phone Book" - Old Node â†’ New Node mapping!            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PATTERN          â”‚ "HashMap Tracking" - Track cloned nodes to avoid loops  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ BASE CASE        â”‚ If None â†’ Return None | If cloned â†’ Return clone       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DEFAULT SOLUTION â”‚ DFS with HashMap (Use in 90% of cases!)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TIME COMPLEXITY  â”‚ O(N+E) - Visit N nodes + E edges                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SPACE COMPLEXITY â”‚ O(N) - HashMap stores N nodes                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        âš¡ QUICK DECISION TABLE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SITUATION                      â”‚ WHICH SOLUTION TO USE?                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Normal interview               â”‚ âœ… Solution 1 (DFS with HashMap)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Want simplest code             â”‚ âœ… Solution 1 (Most natural)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Prefer iteration               â”‚ âš ï¸  Solution 2 (BFS with Queue)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Deep graphs (stack risk)       â”‚ âš ï¸  Solution 2 (BFS avoids stack)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Want to show off               â”‚ ğŸ¯ Write Sol 1, then mention Sol 2       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ğŸ“Š SOLUTION COMPARISON TABLE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CRITERIA         â”‚ SOLUTION 1 (DFS)        â”‚ SOLUTION 2 (BFS Queue)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Code Length      â”‚ â­â­â­â­â­ Very short     â”‚ â­â­â­ More code                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Readability      â”‚ â­â­â­â­â­ Crystal clear  â”‚ â­â­â­â­ Clear                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Interview Speed  â”‚ â­â­â­â­â­ Lightning fast â”‚ â­â­â­ Takes longer             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Stack Safety     â”‚ â­â­â­ Deep recursion    â”‚ â­â­â­â­â­ No stack overflow     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Intuitiveness    â”‚ â­â­â­â­â­ Very natural   â”‚ â­â­â­â­ Also intuitive         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ When to Use      â”‚ 90% of cases (DEFAULT)  â”‚ Very deep graphs only         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â±ï¸  TIME TO MASTER: 20-25 minutes
ğŸ¯ DIFFICULTY: Medium
ğŸ’¡ TIP: Remember "Old â†’ New HashMap" to track cloned nodes!
ğŸ”¥ POPULAR: Common graph cloning interview question!

================================================================================
                           ğŸ¯ PROBLEM UNDERSTANDING
================================================================================

WHAT IS THE PROBLEM?
--------------------
Imagine you have a graph (like a social network). You need to make a COMPLETE
COPY of it - not just copying pointers, but creating entirely new nodes!

REAL WORLD ANALOGY:
------------------
Think of it like copying a FRIEND NETWORK:
- You (Node 1) have friends: [Node 2, Node 4]
- Node 2 has friends: [Node 1, Node 3]
- Node 3 has friends: [Node 2, Node 4]
- Node 4 has friends: [Node 1, Node 3]

You need to create a NEW network with NEW people, but the SAME friendships!

================================================================================
                            ğŸ“ FORMAL PROBLEM
================================================================================

Given a reference of a node in a connected undirected graph, return a deep
copy (clone) of the graph.

Each node in the graph contains:
- A value (val)
- A list of its neighbors (neighbors)

class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

Test case format:
For simplicity, each node's value is the same as the node's index (1-indexed).
For example, the first node with val == 1, the second node with val == 2, etc.
The graph is represented in the test case using an adjacency list.

Example 1:
----------
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation:
There are 4 nodes in the graph.
Node 1: val = 1, neighbors = [2, 4]
Node 2: val = 2, neighbors = [1, 3]
Node 3: val = 3, neighbors = [2, 4]
Node 4: val = 4, neighbors = [1, 3]

Visual representation:
       1 -------- 2
       |          |
       |          |
       4 -------- 3

Example 2:
----------
Input: adjList = [[]]
Output: [[]]
Explanation: Single node with no neighbors.

Example 3:
----------
Input: adjList = []
Output: []
Explanation: Empty graph.

Constraints:
------------
* The number of nodes in the graph is in the range [0, 100].
* 1 <= Node.val <= 100
* Node.val is unique for each node.
* There are no repeated edges and no self-loops in the graph.
* The Graph is connected and all nodes can be visited starting from the given node.

================================================================================
                         ğŸ§  KEY INSIGHTS TO REMEMBER
================================================================================

THE MAIN CHALLENGE:
------------------
âŒ Can't just copy node by node - you'll get infinite loops!
âŒ Can't just copy neighbors directly - they're old references!
âœ… Need to track which nodes you've already cloned!

THE MAGIC TRICK: "Old Node â†’ New Node" MAPPING!
-----------------------------------------------
Think of it as a DICTIONARY/PHONE BOOK:
- Old Node 1 â†’ New Node 1
- Old Node 2 â†’ New Node 2
- Old Node 3 â†’ New Node 3
- Old Node 4 â†’ New Node 4

When you see an old friend, check your phone book:
- Already cloned? Use the cloned version!
- Not cloned yet? Clone them first, add to phone book!

================================================================================
                          ğŸ’¡ SOLUTION APPROACHES
================================================================================
"""

# Definition for a Node.
class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []


# ============================================================================
#                        APPROACH 1: DFS (RECURSIVE)
# ============================================================================

def cloneGraph_DFS(node):
    """
    ğŸ¯ APPROACH 1: DFS with Recursion (MOST INTUITIVE!)

    TIME COMPLEXITY: O(N + E) where N = nodes, E = edges
    SPACE COMPLEXITY: O(N) for the hashmap + O(N) for recursion stack

    ğŸ§  MEMORIZATION TRICK: "Clone & Connect"
    ----------------------------------------
    Think: "Have I cloned you before?"
    - YES â†’ Return the clone from my map
    - NO  â†’ Clone you, then clone all your friends!

    ğŸ“ STEP-BY-STEP ALGORITHM:
    --------------------------
    1. BASE CASE: If node is None, return None
    2. CHECK MAP: Already cloned? Return it!
    3. CLONE NODE: Create new node with same value
    4. ADD TO MAP: old_node â†’ new_node
    5. CLONE NEIGHBORS: Recursively clone each neighbor
    6. RETURN: The cloned node
    """
    if not node:
        return None

    # This is our "phone book" - maps old nodes to new nodes
    old_to_new = {}

    def dfs(node):
        # ğŸ“ Already in our phone book? Return the cloned version!
        if node in old_to_new:
            return old_to_new[node]

        # ğŸ†• Create a NEW person with the same name (value)
        clone = Node(node.val)

        # ğŸ“ Add to phone book IMMEDIATELY (prevents infinite loops!)
        old_to_new[node] = clone

        # ğŸ‘¥ Clone all their friends (neighbors)
        for neighbor in node.neighbors:
            clone.neighbors.append(dfs(neighbor))

        return clone

    return dfs(node)


# ============================================================================
#                        APPROACH 2: BFS (ITERATIVE)
# ============================================================================

def cloneGraph_BFS(node):
    """
    ğŸ¯ APPROACH 2: BFS with Queue (LEVEL BY LEVEL)

    TIME COMPLEXITY: O(N + E) where N = nodes, E = edges
    SPACE COMPLEXITY: O(N) for the hashmap + O(N) for the queue

    ğŸ§  MEMORIZATION TRICK: "Clone Level by Level"
    ---------------------------------------------
    Think: Process one person at a time in a queue
    - Clone the person
    - Add them to phone book
    - Clone their friends

    ğŸ“ STEP-BY-STEP ALGORITHM:
    --------------------------
    1. BASE CASE: If node is None, return None
    2. CREATE QUEUE: Start with original node
    3. CLONE ROOT: Create clone and add to map
    4. PROCESS QUEUE:
       - For each node in queue
       - For each neighbor:
         * Not cloned? Clone and add to queue
         * Connect cloned node to cloned neighbor
    5. RETURN: The cloned root
    """
    if not node:
        return None

    from collections import deque

    # Phone book: old â†’ new mapping
    old_to_new = {}

    # Clone the starting node
    old_to_new[node] = Node(node.val)

    # Queue for BFS
    queue = deque([node])

    while queue:
        current = queue.popleft()

        # Process each neighbor
        for neighbor in current.neighbors:
            # Haven't cloned this neighbor yet?
            if neighbor not in old_to_new:
                # Clone it!
                old_to_new[neighbor] = Node(neighbor.val)
                # Add to queue to process its neighbors later
                queue.append(neighbor)

            # Connect the cloned current node to cloned neighbor
            old_to_new[current].neighbors.append(old_to_new[neighbor])

    return old_to_new[node]


# ============================================================================
#                    ğŸ¨ VISUAL WALKTHROUGH EXAMPLE
# ============================================================================

"""
Let's walk through Example 1: [[2,4],[1,3],[2,4],[1,3]]

Original Graph:
       1 -------- 2
       |          |
       |          |
       4 -------- 3

STEP-BY-STEP DFS:
-----------------

1. Start at Node 1
   - Not in map â†’ Create clone: Node(1)
   - Add to map: {1 â†’ Node(1)}
   - Clone neighbors [2, 4]

2. Clone Node 2 (from Node 1's neighbor)
   - Not in map â†’ Create clone: Node(2)
   - Add to map: {1 â†’ Node(1), 2 â†’ Node(2)}
   - Clone neighbors [1, 3]

3. Clone Node 1 (from Node 2's neighbor)
   - Already in map! Return existing clone

4. Clone Node 3 (from Node 2's neighbor)
   - Not in map â†’ Create clone: Node(3)
   - Add to map: {1 â†’ Node(1), 2 â†’ Node(2), 3 â†’ Node(3)}
   - Clone neighbors [2, 4]

5. Clone Node 2 (from Node 3's neighbor)
   - Already in map! Return existing clone

6. Clone Node 4 (from Node 3's neighbor)
   - Not in map â†’ Create clone: Node(4)
   - Add to map: {1 â†’ Node(1), 2 â†’ Node(2), 3 â†’ Node(3), 4 â†’ Node(4)}
   - Clone neighbors [1, 3]

7. Clone Node 1 (from Node 4's neighbor)
   - Already in map! Return existing clone

8. Clone Node 3 (from Node 4's neighbor)
   - Already in map! Return existing clone

9. Clone Node 4 (from Node 1's neighbor)
   - Already in map! Return existing clone

DONE! Cloned Graph:
       1' ------- 2'
       |          |
       |          |
       4' ------- 3'
"""

# ============================================================================
#              ğŸ¯ MEMORY TRICKS & COMMON MISTAKES
# ============================================================================

"""
ğŸ§  HOW TO REMEMBER THIS SOLUTION:
---------------------------------
1. "PHONE BOOK" â†’ Use a HashMap (old â†’ new)
2. "CHECK FIRST" â†’ Always check if already cloned
3. "CLONE EARLY" â†’ Add to map BEFORE processing neighbors
4. "RECURSIVE" â†’ DFS is natural for graphs

âŒ COMMON MISTAKES TO AVOID:
----------------------------
1. âŒ Forgetting to add to map before processing neighbors
      â†’ Causes infinite recursion!

2. âŒ Not checking if node is None
      â†’ Causes NullPointerException!

3. âŒ Cloning neighbors directly without checking map
      â†’ Creates duplicate clones!

4. âŒ Not using a map at all
      â†’ Infinite loops everywhere!

âœ… PRO TIPS:
-----------
1. DFS is more intuitive (use recursion)
2. BFS is better if you want level-by-level processing
3. The MAP is the KEY - without it, you're lost!
4. Always add to map IMMEDIATELY after creating clone
"""

# ============================================================================
#                         ğŸ§ª TEST CASES
# ============================================================================

def buildGraph(adjList):
    """Helper function to build graph from adjacency list"""
    if not adjList:
        return None

    nodes = {i + 1: Node(i + 1) for i in range(len(adjList))}

    for i, neighbors in enumerate(adjList):
        node = nodes[i + 1]
        for neighbor_val in neighbors:
            node.neighbors.append(nodes[neighbor_val])

    return nodes[1] if nodes else None


def printGraph(node):
    """Helper function to print graph"""
    if not node:
        print("[]")
        return

    visited = set()
    result = []

    def dfs(node):
        if node.val in visited:
            return
        visited.add(node.val)
        neighbors = [n.val for n in node.neighbors]
        result.append([node.val, neighbors])
        for neighbor in node.neighbors:
            dfs(neighbor)

    dfs(node)
    for val, neighbors in sorted(result):
        print(f"Node {val}: neighbors = {neighbors}")


if __name__ == "__main__":
    print("="*70)
    print("                    CLONE GRAPH - TEST CASES")
    print("="*70)

    # Test Case 1: 4-node cycle graph
    print("\nğŸ“ Test Case 1: 4-node cycle graph")
    print("-" * 70)
    adjList1 = [[2,4],[1,3],[2,4],[1,3]]
    graph1 = buildGraph(adjList1)
    print("Original Graph:")
    printGraph(graph1)

    cloned1 = cloneGraph_DFS(graph1)
    print("\nCloned Graph:")
    printGraph(cloned1)

    # Test Case 2: Single node
    print("\nğŸ“ Test Case 2: Single node")
    print("-" * 70)
    adjList2 = [[]]
    graph2 = buildGraph(adjList2)
    print("Original Graph:")
    printGraph(graph2)

    cloned2 = cloneGraph_DFS(graph2)
    print("\nCloned Graph:")
    printGraph(cloned2)

    # Test Case 3: Empty graph
    print("\nğŸ“ Test Case 3: Empty graph")
    print("-" * 70)
    adjList3 = []
    graph3 = buildGraph(adjList3)
    print("Original Graph:")
    printGraph(graph3)

    cloned3 = cloneGraph_DFS(graph3)
    print("\nCloned Graph:")
    printGraph(cloned3)

    print("\n" + "="*70)
    print("              âœ… ALL TEST CASES COMPLETED!")
    print("="*70)


# ============================================================================
#              ğŸ“ LEARNING SUMMARY & KEY TAKEAWAYS
# ============================================================================

"""
ğŸ¯ WHAT YOU LEARNED:
-------------------
1. Graph cloning requires a MAPPING (old â†’ new)
2. DFS and BFS both work - choose your favorite
3. Add to map BEFORE processing neighbors (critical!)
4. HashMap prevents infinite loops

ğŸ”‘ KEY PATTERN: "Clone with HashMap"
------------------------------------
This pattern applies to:
- Clone Graph (this problem)
- Copy List with Random Pointer
- Deep Copy of any connected structure

ğŸ’ª PRACTICE VARIATIONS:
----------------------
Try these similar problems:
1. LeetCode #138: Copy List with Random Pointer
2. LeetCode #1485: Clone Binary Tree With Random Pointer
3. LeetCode #1490: Clone N-ary Tree

ğŸ‰ CONGRATULATIONS!
------------------
You now understand how to clone a graph!
Remember: "Phone Book" (HashMap) is your best friend!
"""
