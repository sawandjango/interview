"""
LeetCode Problem #23: Merge k Sorted Lists

Difficulty: Hard
Topics: Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort
Companies: Amazon, Facebook, Google, Microsoft, Apple, Bloomberg, Uber, LinkedIn, Adobe

================================================================================
                    ğŸ“š QUICK REFERENCE - WHAT'S IN THIS FILE
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ğŸ“– TABLE OF CONTENTS                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ #    â”‚ SECTION                              â”‚ WHAT YOU'LL LEARN             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1    â”‚ ğŸ¯ PROBLEM UNDERSTANDING             â”‚ â€¢ What is being asked?        â”‚
â”‚      â”‚                                      â”‚ â€¢ Real-world analogies        â”‚
â”‚      â”‚                                      â”‚ â€¢ Visual examples             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2    â”‚ ğŸ§  KEY INSIGHTS TO REMEMBER          â”‚ â€¢ Main challenge              â”‚
â”‚      â”‚                                      â”‚ â€¢ Base cases to handle        â”‚
â”‚      â”‚                                      â”‚ â€¢ Pattern recognition         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3    â”‚ ğŸš€ HOW TO APPROACH THIS PROBLEM      â”‚ â€¢ Step-by-step process        â”‚
â”‚      â”‚                                      â”‚ â€¢ Decision tree               â”‚
â”‚      â”‚                                      â”‚ â€¢ Interview scenarios         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4    â”‚ ğŸ’¡ SOLUTION 1: Min Heap â­          â”‚ â€¢ WHY choose? (Pros/Cons)     â”‚
â”‚      â”‚    (OPTIMAL - O(N log k))            â”‚ â€¢ WHEN to use?                â”‚
â”‚      â”‚                                      â”‚ â€¢ Step-by-step walkthrough    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 5    â”‚ ğŸ’¡ SOLUTION 2: Divide & Conquer      â”‚ â€¢ WHY choose? (Pros/Cons)     â”‚
â”‚      â”‚    (O(N log k) - Recursive!)         â”‚ â€¢ WHEN to use?                â”‚
â”‚      â”‚                                      â”‚ â€¢ Comparison with Solution 1  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 6    â”‚ ğŸ’¡ SOLUTION 3: Brute Force           â”‚ â€¢ WHY choose? (Pros/Cons)     â”‚
â”‚      â”‚    (Simple but O(N log N))           â”‚ â€¢ WHEN to use?                â”‚
â”‚      â”‚                                      â”‚ â€¢ Educational approach        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 7    â”‚ ğŸ’» IMPLEMENTATION                    â”‚ â€¢ Clean, commented code       â”‚
â”‚      â”‚                                      â”‚ â€¢ All three solutions         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 8    â”‚ ğŸ§ª TEST CASES                        â”‚ â€¢ Comprehensive tests         â”‚
â”‚      â”‚                                      â”‚ â€¢ Edge cases covered          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 9    â”‚ ğŸ“ LEARNING SUMMARY                  â”‚ â€¢ Key takeaways               â”‚
â”‚      â”‚                                      â”‚ â€¢ Memory tricks               â”‚
â”‚      â”‚                                      â”‚ â€¢ Common mistakes             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 10   â”‚ ğŸ”— RELATED PROBLEMS                  â”‚ â€¢ Similar problems            â”‚
â”‚      â”‚                                      â”‚ â€¢ Pattern recognition         â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ğŸ¯ MEMORY CHEAT SHEET                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ANALOGY          â”‚ "K-Way Merge" - Merge k sorted streams into one!       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PATTERN          â”‚ "Min Heap of Heads" - Always pick smallest next node!  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ KEY TRICK        â”‚ Heap stores (value, index, node) - O(log k) per pick!  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DEFAULT SOLUTION â”‚ Min Heap (O(N log k) - OPTIMAL!)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TIME COMPLEXITY  â”‚ O(N log k) where N = total nodes, k = number of lists  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SPACE COMPLEXITY â”‚ O(k) - Heap stores at most k nodes                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        âš¡ QUICK DECISION TABLE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SITUATION                          â”‚ WHICH SOLUTION TO USE?                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Normal interview (want best)       â”‚ âœ… Solution 1 (Min Heap)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Need optimal O(N log k)            â”‚ âœ… Solution 1 (Min Heap!)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Want elegant recursive solution    â”‚ âš¡ Solution 2 (Divide & Conquer)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Learning merge sort pattern        â”‚ ğŸ“ Solution 2 (D&C - educational)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Want simplest code                 â”‚ âš ï¸  Solution 3 (Brute Force)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Want to show optimization          â”‚ ğŸ¯ Start with Sol 3, optimize to 1   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ğŸ“Š SOLUTION COMPARISON TABLE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CRITERIA         â”‚ MIN HEAP     â”‚ DIVIDE & CON â”‚ BRUTE FORCE  â”‚ WINNER      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Time Complexity  â”‚ â­â­â­â­â­   â”‚ â­â­â­â­â­   â”‚ â­â­â­       â”‚ Both Heap   â”‚
â”‚                  â”‚ O(N log k)   â”‚ O(N log k)   â”‚ O(N log N)   â”‚ & D&C       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Space Complexity â”‚ â­â­â­â­     â”‚ â­â­â­       â”‚ â­â­â­       â”‚ Min Heap    â”‚
â”‚                  â”‚ O(k)         â”‚ O(log k)     â”‚ O(N)         â”‚             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Code Simplicity  â”‚ â­â­â­â­     â”‚ â­â­â­â­     â”‚ â­â­â­â­â­   â”‚ Brute Force â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Interview Speed  â”‚ â­â­â­â­     â”‚ â­â­â­â­â­   â”‚ â­â­â­â­     â”‚ D&C         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Scalability      â”‚ â­â­â­â­â­   â”‚ â­â­â­â­â­   â”‚ â­â­         â”‚ Both Heap   â”‚
â”‚                  â”‚              â”‚              â”‚              â”‚ & D&C       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Overall Best     â”‚ âœ… OPTIMAL   â”‚ âœ… OPTIMAL   â”‚ Simple       â”‚ Both!       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â±ï¸  TIME TO MASTER: 30-35 minutes
ğŸ¯ DIFFICULTY: Hard (but pattern is beautiful!)
ğŸ’¡ TIP: "Min heap of list heads - always pick smallest next!"
ğŸ”¥ POPULAR: Classic k-way merge - asked at all top companies!

================================================================================
                           ğŸ¯ PROBLEM UNDERSTANDING
================================================================================

WHAT IS THE PROBLEM?
--------------------
You have k sorted linked lists. Merge them into one sorted linked list.

REAL WORLD ANALOGY:
------------------
Think of MERGING K SORTED FILES:
- You have k log files, each sorted by timestamp
- Log1: [1:00, 3:00, 5:00, ...]
- Log2: [2:00, 4:00, 6:00, ...]
- Log3: [1:30, 2:30, 7:00, ...]
- Need to merge into single chronological log
- Always pick earliest timestamp from all k files!

Another analogy - MERGING SORTED ARRAYS IN DATABASE:
- K database partitions, each sorted
- Partition1: [1, 4, 7, ...]
- Partition2: [2, 5, 8, ...]
- Partition3: [3, 6, 9, ...]
- Need to produce single sorted result
- K-way merge: pick smallest element from k sources!

THE KEY INSIGHT:
---------------
Use MIN HEAP to track the "head" of each list!
- Heap stores smallest element from each list
- Pop smallest from heap â†’ add to result
- Push next element from that list â†’ heap
- Repeat until all lists exhausted

Example: 3 lists
  List1: [1â†’4â†’5]
  List2: [1â†’3â†’4]
  List3: [2â†’6]

Step 1: Heap = [1(L1), 1(L2), 2(L3)] â†’ Pick 1 from L1
Step 2: Heap = [1(L2), 2(L3), 4(L1)] â†’ Pick 1 from L2
Step 3: Heap = [2(L3), 3(L2), 4(L1)] â†’ Pick 2 from L3
... Continue until all merged!

âŒ Wrong thinking: "Merge lists one by one" â†’ O(kN) time!
âœ… Right thinking: "Use heap to merge k-way in parallel" â†’ O(N log k)!

================================================================================
                            ğŸ“ FORMAL PROBLEM
================================================================================

You are given an array of k linked-lists lists, each linked-list is sorted in
ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

Example 1:
----------
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
Merging them into one sorted list:
1->1->2->3->4->4->5->6

Example 2:
----------
Input: lists = []
Output: []

Example 3:
----------
Input: lists = [[]]
Output: []

Constraints:
------------
* k == lists.length
* 0 <= k <= 10^4
* 0 <= lists[i].length <= 500
* -10^4 <= lists[i][j] <= 10^4
* lists[i] is sorted in ascending order
* The sum of lists[i].length will not exceed 10^4

================================================================================
                         ğŸ§  KEY INSIGHTS TO REMEMBER
================================================================================

THE MAIN CHALLENGE:
------------------
âŒ Merging k lists one-by-one is O(kN) - too slow!
âŒ Collecting all nodes and sorting is O(N log N) - not optimal!
âœ… K-way merge using min heap is O(N log k) - optimal!

THE MAGIC TRICK: "MIN HEAP OF LIST HEADS"
------------------------------------------
Key observation: At any moment, the next smallest node must be at the HEAD
of one of the k lists!

K-way Merge Strategy:
  List1: [1] â†’ 4 â†’ 5
  List2: [1] â†’ 3 â†’ 4
  List3: [2] â†’ 6

  Heap contains heads: [1(L1), 1(L2), 2(L3)]
  Next smallest MUST be one of these 3!

Algorithm:
1. Add all k list heads to min heap
2. Pop smallest from heap â†’ add to result
3. If popped node has next â†’ add next to heap
4. Repeat until heap empty

THE BREAKTHROUGH INSIGHT:
------------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  K-way merge via min heap:                                 â”‚
â”‚  - Heap size always â‰¤ k (one head per list)                â”‚
â”‚  - Each pop: O(log k)                                      â”‚
â”‚  - Total N pops (N = total nodes)                          â”‚
â”‚  â†’ Total: O(N log k) time, O(k) space!                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHY THIS IS O(N log k):
-----------------------
- Total nodes to process: N
- Each heap operation (push/pop): O(log k)
- Heap never exceeds size k
- Total operations: N Ã— O(log k) = O(N log k) âœ…

ALTERNATIVE: DIVIDE AND CONQUER
--------------------------------
Merge lists in pairs recursively:
  Round 1: k lists â†’ k/2 lists
  Round 2: k/2 lists â†’ k/4 lists
  ...
  Final: 1 list

Time: O(N log k) - log k rounds, each round processes N nodes
Space: O(log k) - recursion depth

================================================================================
                          ğŸ’¡ SOLUTION APPROACHES
================================================================================
"""

from typing import List, Optional
import heapq

# Definition for singly-linked list
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# ============================================================================
#              APPROACH 1: MIN HEAP (OPTIMAL - O(N log k))
# ============================================================================

def mergeKLists_MinHeap(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    """
    ğŸ¯ APPROACH 1: Min Heap of List Heads (BEST SOLUTION!)

    TIME COMPLEXITY: O(N log k) where N = total nodes, k = number of lists
    SPACE COMPLEXITY: O(k) - Heap stores at most k nodes

    ğŸ§  MEMORIZATION TRICK: "K-Way Merge via Heap"
    ----------------------------------------------
    Think: Track smallest head from k lists at all times!
    - Heap contains one node from each list
    - Pop smallest â†’ add to result
    - Push next from that list â†’ heap
    - Repeat until all exhausted

    ğŸ“ STEP-BY-STEP ALGORITHM:
    --------------------------
    1. Create min heap
    2. Add all k list heads to heap (skip empty lists)
    3. Create dummy head for result list
    4. While heap not empty:
       a. Pop smallest node from heap
       b. Append to result list
       c. If popped node has next: add next to heap
    5. Return dummy.next

    ğŸ¨ VISUAL EXAMPLE:
    -----------------
    Input: lists = [[1,4,5],[1,3,4],[2,6]]

    Initial state:
      L1: 1 â†’ 4 â†’ 5
      L2: 1 â†’ 3 â†’ 4
      L3: 2 â†’ 6

    Step 1: Build heap with heads
      Heap: [(1,0,L1[0]), (1,1,L2[0]), (2,2,L3[0])]
             â†‘ smallest

    Step 2: Pop (1,0,L1[0]), add to result, push L1[1]
      Result: 1
      Heap: [(1,1,L2[0]), (2,2,L3[0]), (4,0,L1[1])]

    Step 3: Pop (1,1,L2[0]), add to result, push L2[1]
      Result: 1â†’1
      Heap: [(2,2,L3[0]), (3,1,L2[1]), (4,0,L1[1])]

    Step 4: Pop (2,2,L3[0]), add to result, push L3[1]
      Result: 1â†’1â†’2
      Heap: [(3,1,L2[1]), (4,0,L1[1]), (6,2,L3[1])]

    ... Continue until heap empty

    Final: 1â†’1â†’2â†’3â†’4â†’4â†’5â†’6 âœ…

    WHY THIS IS O(N log k):
    ----------------------
    âœ… Build initial heap: O(k log k)
    âœ… Process N nodes total
    âœ… Each pop/push: O(log k)
    âœ… Total: O(k log k + N log k) = O(N log k)
    """
    # Handle edge cases
    if not lists or len(lists) == 0:
        return None

    # Min heap: stores (node.val, list_index, node)
    # list_index ensures stable ordering for equal values
    heap = []

    # Add all list heads to heap (skip empty lists)
    for i, head in enumerate(lists):
        if head:
            heapq.heappush(heap, (head.val, i, head))

    # Create dummy head for result
    dummy = ListNode(0)
    current = dummy

    # K-way merge using heap
    while heap:
        # Pop smallest node
        val, list_idx, node = heapq.heappop(heap)

        # Add to result
        current.next = node
        current = current.next

        # If this list has more nodes, add next to heap
        if node.next:
            heapq.heappush(heap, (node.next.val, list_idx, node.next))

    return dummy.next


# ============================================================================
#          APPROACH 2: DIVIDE AND CONQUER (O(N log k) - ELEGANT!)
# ============================================================================

def mergeKLists_DivideConquer(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    """
    ğŸ¯ APPROACH 2: Divide and Conquer (ELEGANT RECURSIVE!)

    TIME COMPLEXITY: O(N log k) - log k merge rounds, each processes N nodes
    SPACE COMPLEXITY: O(log k) - Recursion depth

    ğŸ§  MEMORIZATION TRICK: "Merge Sort Pattern"
    -------------------------------------------
    Think: Merge lists in pairs, recursively!
    - Divide k lists into pairs
    - Merge each pair â†’ k/2 lists
    - Recursively merge k/2 lists
    - Base case: 1 or 2 lists

    ğŸ“ ALGORITHM:
    ------------
    mergeLists(lists, left, right):
      1. If left == right: return lists[left]
      2. If left + 1 == right: return merge2Lists(lists[left], lists[right])
      3. mid = (left + right) // 2
      4. leftMerged = mergeLists(lists, left, mid)
      5. rightMerged = mergeLists(lists, mid+1, right)
      6. Return merge2Lists(leftMerged, rightMerged)

    ğŸ¨ VISUAL EXAMPLE:
    -----------------
    Input: 4 lists [L1, L2, L3, L4]

    Round 1: Merge pairs
      [L1, L2, L3, L4]
       â””â”€â”¬â”€â”˜  â””â”€â”¬â”€â”˜
        M1      M2

    Round 2: Merge results
      [M1, M2]
       â””â”€â”€â”¬â”€â”€â”˜
         Final

    Recursion tree:
                  merge(0,3)
                 /          \
          merge(0,1)      merge(2,3)
          /      \        /      \
      merge(0,0) merge(1,1) merge(2,2) merge(3,3)
         L1       L2        L3        L4

    Depth = log k
    Each level processes all N nodes â†’ O(N) per level
    Total: O(N log k) âœ…

    WHY THIS WORKS:
    ---------------
    âœ… Each merge of 2 lists: O(n1 + n2)
    âœ… log k levels of merging
    âœ… Total nodes at each level: N
    âœ… Total: O(N log k)
    """

    def merge2Lists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        """Merge two sorted lists in O(n1 + n2) time."""
        dummy = ListNode(0)
        current = dummy

        while l1 and l2:
            if l1.val <= l2.val:
                current.next = l1
                l1 = l1.next
            else:
                current.next = l2
                l2 = l2.next
            current = current.next

        # Attach remaining nodes
        current.next = l1 if l1 else l2
        return dummy.next

    def mergeLists(left: int, right: int) -> Optional[ListNode]:
        """Recursively merge lists from index left to right."""
        # Base case: no lists
        if left > right:
            return None

        # Base case: single list
        if left == right:
            return lists[left]

        # Divide and conquer
        mid = (left + right) // 2
        leftMerged = mergeLists(left, mid)
        rightMerged = mergeLists(mid + 1, right)

        return merge2Lists(leftMerged, rightMerged)

    # Handle edge cases
    if not lists or len(lists) == 0:
        return None

    return mergeLists(0, len(lists) - 1)


# ============================================================================
#              APPROACH 3: BRUTE FORCE (SIMPLE BUT O(N log N))
# ============================================================================

def mergeKLists_BruteForce(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    """
    ğŸ¯ APPROACH 3: Collect All and Sort (SIMPLEST!)

    TIME COMPLEXITY: O(N log N) - Collect O(N), sort O(N log N)
    SPACE COMPLEXITY: O(N) - Store all node values

    ğŸ§  MEMORIZATION TRICK: "Flatten and Sort"
    -----------------------------------------
    Think: Collect all values, sort, rebuild list!
    - Traverse all k lists
    - Collect all values in array
    - Sort array
    - Build new linked list from sorted array

    ğŸ“ ALGORITHM:
    ------------
    1. Collect all node values from k lists into array
    2. Sort the array
    3. Build new linked list from sorted array
    4. Return new list

    ğŸ¨ EXAMPLE:
    ----------
    Input: lists = [[1,4,5],[1,3,4],[2,6]]

    Step 1: Collect all values
      values = [1, 4, 5, 1, 3, 4, 2, 6]

    Step 2: Sort
      values = [1, 1, 2, 3, 4, 4, 5, 6]

    Step 3: Build linked list
      1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4 â†’ 5 â†’ 6 âœ…

    âš ï¸  WHY NOT OPTIMAL:
    -------------------
    - Sorting is O(N log N)
    - Heap/D&C approach is O(N log k)
    - When k << N, O(N log k) is much better!
    - But: VERY simple to code!
    """
    # Collect all values
    values = []
    for head in lists:
        current = head
        while current:
            values.append(current.val)
            current = current.next

    # Sort values
    values.sort()

    # Build new linked list
    dummy = ListNode(0)
    current = dummy
    for val in values:
        current.next = ListNode(val)
        current = current.next

    return dummy.next


# ============================================================================
#                    ğŸ¨ VISUAL WALKTHROUGH EXAMPLE
# ============================================================================

"""
Let's trace Min Heap approach with: lists = [[1,4,5],[1,3,4],[2,6]]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                          APPROACH 1: MIN HEAP (OPTIMAL)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INITIAL INPUT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
k = 3 lists:
  List 0: 1 â†’ 4 â†’ 5 â†’ None
  List 1: 1 â†’ 3 â†’ 4 â†’ None
  List 2: 2 â†’ 6 â†’ None

Total nodes: N = 8

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INITIALIZATION: Build heap with all list heads                                                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   List 0 head: node(val=1) â†’ Add to heap                                                                                      â”‚
â”‚   List 1 head: node(val=1) â†’ Add to heap                                                                                      â”‚
â”‚   List 2 head: node(val=2) â†’ Add to heap                                                                                      â”‚
â”‚                                                                                                                                 â”‚
â”‚   Initial Heap State:                                                                                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚   â”‚ Heap: [(1, 0, L0[0]), (1, 1, L1[0]), (2, 2, L2[0])]          â”‚                                                            â”‚
â”‚   â”‚        â†‘ smallest val  â†‘ list index  â†‘ node                  â”‚                                                            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   Min Heap Structure:                                                                                                          â”‚
â”‚            (1,0,L0[0])  â† Top (smallest)                                                                                       â”‚
â”‚           /            \                                                                                                       â”‚
â”‚   (1,1,L1[0])      (2,2,L2[0])                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   Result list: dummy â†’ (empty)                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ITERATION 1: Pop smallest, append to result                                                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Step 1: heappop() â†’ (1, 0, L0[0])                                                                                            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                          â”‚
â”‚   Popped node: val=1 from List 0                                                                                               â”‚
â”‚   Current list states:                                                                                                         â”‚
â”‚     List 0: [1] â†’ 4 â†’ 5    (popped this 1)                                                                                     â”‚
â”‚     List 1:  1 â†’ 3 â†’ 4                                                                                                         â”‚
â”‚     List 2:  2 â†’ 6                                                                                                             â”‚
â”‚                                                                                                                                 â”‚
â”‚   Step 2: Append to result                                                                                                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                     â”‚
â”‚   Result: dummy â†’ 1                                                                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   Step 3: Push L0[0].next (node val=4) to heap                                                                                â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                 â”‚
â”‚   heappush((4, 0, L0[1]))                                                                                                      â”‚
â”‚                                                                                                                                 â”‚
â”‚   Heap after push:                                                                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚   â”‚ Heap: [(1, 1, L1[0]), (2, 2, L2[0]), (4, 0, L0[1])]          â”‚                                                            â”‚
â”‚   â”‚        â†‘ smallest now is val=1 from List 1                   â”‚                                                            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   Min Heap Structure:                                                                                                          â”‚
â”‚            (1,1,L1[0])  â† Top                                                                                                  â”‚
â”‚           /            \                                                                                                       â”‚
â”‚   (2,2,L2[0])      (4,0,L0[1])                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   Result so far: 1                                                                                                             â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ITERATION 2: Pop smallest (1 from L1)                                                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Step 1: heappop() â†’ (1, 1, L1[0])                                                                                            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                          â”‚
â”‚   Popped node: val=1 from List 1                                                                                               â”‚
â”‚   Current list states:                                                                                                         â”‚
â”‚     List 0:  4 â†’ 5                                                                                                             â”‚
â”‚     List 1: [1] â†’ 3 â†’ 4    (popped this 1)                                                                                     â”‚
â”‚     List 2:  2 â†’ 6                                                                                                             â”‚
â”‚                                                                                                                                 â”‚
â”‚   Step 2: Append to result                                                                                                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                     â”‚
â”‚   Result: dummy â†’ 1 â†’ 1                                                                                                        â”‚
â”‚                                                                                                                                 â”‚
â”‚   Step 3: Push L1[0].next (node val=3) to heap                                                                                â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                 â”‚
â”‚   heappush((3, 1, L1[1]))                                                                                                      â”‚
â”‚                                                                                                                                 â”‚
â”‚   Heap after push:                                                                                                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                            â”‚
â”‚   â”‚ Heap: [(2, 2, L2[0]), (3, 1, L1[1]), (4, 0, L0[1])]          â”‚                                                            â”‚
â”‚   â”‚        â†‘ smallest now is val=2 from List 2                   â”‚                                                            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   Result so far: 1 â†’ 1                                                                                                         â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ITERATION 3: Pop smallest (2 from L2)                                                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Step 1: heappop() â†’ (2, 2, L2[0])                                                                                            â”‚
â”‚   Step 2: Append to result â†’ Result: 1 â†’ 1 â†’ 2                                                                                â”‚
â”‚   Step 3: Push L2[0].next (val=6) â†’ heappush((6, 2, L2[1]))                                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚   Heap: [(3, 1, L1[1]), (4, 0, L0[1]), (6, 2, L2[1])]                                                                         â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ITERATION 4: Pop smallest (3 from L1)                                                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Step 1: heappop() â†’ (3, 1, L1[1])                                                                                            â”‚
â”‚   Step 2: Append to result â†’ Result: 1 â†’ 1 â†’ 2 â†’ 3                                                                            â”‚
â”‚   Step 3: Push L1[1].next (val=4) â†’ heappush((4, 1, L1[2]))                                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚   Heap: [(4, 0, L0[1]), (4, 1, L1[2]), (6, 2, L2[1])]                                                                         â”‚
â”‚           â†‘ Two 4's! Tie-break by list index (0 < 1)                                                                          â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ITERATION 5: Pop smallest (4 from L0)                                                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Step 1: heappop() â†’ (4, 0, L0[1])  â† Index 0 wins tie!                                                                      â”‚
â”‚   Step 2: Append to result â†’ Result: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4                                                                        â”‚
â”‚   Step 3: Push L0[1].next (val=5) â†’ heappush((5, 0, L0[2]))                                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚   Heap: [(4, 1, L1[2]), (5, 0, L0[2]), (6, 2, L2[1])]                                                                         â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ITERATION 6: Pop smallest (4 from L1)                                                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Step 1: heappop() â†’ (4, 1, L1[2])                                                                                            â”‚
â”‚   Step 2: Append to result â†’ Result: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4                                                                    â”‚
â”‚   Step 3: L1[2].next is None â†’ Don't push anything                                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   Heap: [(5, 0, L0[2]), (6, 2, L2[1])]                                                                                         â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ITERATION 7: Pop smallest (5 from L0)                                                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Step 1: heappop() â†’ (5, 0, L0[2])                                                                                            â”‚
â”‚   Step 2: Append to result â†’ Result: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4 â†’ 5                                                                â”‚
â”‚   Step 3: L0[2].next is None â†’ Don't push anything                                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   Heap: [(6, 2, L2[1])]                                                                                                        â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ITERATION 8: Pop last node (6 from L2)                                                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Step 1: heappop() â†’ (6, 2, L2[1])                                                                                            â”‚
â”‚   Step 2: Append to result â†’ Result: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4 â†’ 5 â†’ 6 âœ…                                                         â”‚
â”‚   Step 3: L2[1].next is None â†’ Don't push anything                                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   Heap: [] (empty!)                                                                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   DONE! Return dummy.next                                                                                                      â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FINAL RESULT: 1 â†’ 1 â†’ 2 â†’ 3 â†’ 4 â†’ 4 â†’ 5 â†’ 6

COMPLEXITY ANALYSIS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Time: O(N log k)
  - N = 8 total nodes
  - k = 3 lists
  - Each heap operation: O(log 3) â‰ˆ O(1.58)
  - Total: 8 Ã— log(3) â‰ˆ 12.7 operations âœ…

Space: O(k) = O(3) - Heap never exceeds k nodes

KEY OBSERVATIONS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Heap size never exceeds k (number of lists)
2. Each node processed exactly once (N operations)
3. Stable ordering maintained via list index in heap tuple
4. No extra space for storing all nodes (unlike brute force)
5. Efficient k-way merge in O(N log k) time!
"""

# ============================================================================
#              ğŸ¯ MEMORY TRICKS & COMMON MISTAKES
# ============================================================================

"""
ğŸ§  HOW TO REMEMBER THIS SOLUTION:
---------------------------------
1. "K-WAY MERGE" â†’ Track k list heads in min heap
2. "POP SMALLEST, PUSH NEXT" â†’ Heap ensures smallest always on top
3. "HEAP SIZE â‰¤ K" â†’ At most one node per list in heap
4. "O(N log k) NOT O(N log N)" â†’ Key optimization over sorting!

âŒ COMMON MISTAKES TO AVOID:
----------------------------
1. âŒ Merging lists one by one sequentially
      WRONG: merge(merge(merge(L1, L2), L3), L4) â†’ O(kN)
      RIGHT: Use heap for k-way parallel merge â†’ O(N log k)

2. âŒ Forgetting to handle empty lists
      WRONG: Add all heads to heap without checking
      RIGHT: Skip empty lists when building initial heap

3. âŒ Not using list index in heap tuple
      WRONG: heappush((node.val, node)) â†’ Error for equal values
      RIGHT: heappush((node.val, list_idx, node)) â†’ Stable sort

4. âŒ Creating new nodes instead of reusing
      WRONG: current.next = ListNode(val)
      RIGHT: current.next = node (reuse existing nodes)

5. âŒ Forgetting dummy head pattern
      WRONG: Complex logic for first node
      RIGHT: Use dummy head, return dummy.next

6. âŒ Confusing O(N log k) vs O(N log N)
      WRONG: Thinking heap approach is O(N log N)
      RIGHT: Heap size is k, so O(log k) per operation!

âœ… PRO TIPS:
-----------
1. Min heap approach is most common in interviews
2. Divide & conquer shows strong recursion skills
3. Always handle edge cases: empty list, single list
4. Reuse nodes - don't create new ones!
5. This pattern extends to merging k sorted arrays

ğŸ¯ INTERVIEW STRATEGY:
---------------------
"I'll use a min heap to track the smallest unprocessed node from each list.
Initially, I add all k list heads to the heap. Then I repeatedly pop the
smallest node, add it to the result, and push the next node from that list
to the heap. This gives O(N log k) time where N is total nodes and k is
number of lists, which is optimal. Space is O(k) for the heap."

Alternative:
"I can also use divide and conquer - merge lists in pairs recursively,
similar to merge sort. This also achieves O(N log k) time with O(log k)
space for recursion, and shows strong understanding of D&C patterns."
"""

# ============================================================================
#                         ğŸ§ª TEST CASES
# ============================================================================

if __name__ == "__main__":
    print("="*80)
    print("          MERGE K SORTED LISTS - TEST CASES")
    print("="*80)

    # Helper function to create linked list from array
    def createList(arr):
        if not arr:
            return None
        dummy = ListNode(0)
        current = dummy
        for val in arr:
            current.next = ListNode(val)
            current = current.next
        return dummy.next

    # Helper function to convert linked list to array
    def listToArray(head):
        result = []
        current = head
        while current:
            result.append(current.val)
            current = current.next
        return result

    # Test Case 1: Standard case from problem
    print("\nğŸ“ Test Case 1: Standard case (3 lists)")
    print("-" * 80)
    lists1 = [
        createList([1, 4, 5]),
        createList([1, 3, 4]),
        createList([2, 6])
    ]
    print("Input: [[1,4,5],[1,3,4],[2,6]]")

    result1_a = mergeKLists_MinHeap(lists1)
    result1_arr_a = listToArray(result1_a)

    # Recreate lists for other approaches
    lists1_b = [createList([1, 4, 5]), createList([1, 3, 4]), createList([2, 6])]
    result1_b = mergeKLists_DivideConquer(lists1_b)
    result1_arr_b = listToArray(result1_b)

    lists1_c = [createList([1, 4, 5]), createList([1, 3, 4]), createList([2, 6])]
    result1_c = mergeKLists_BruteForce(lists1_c)
    result1_arr_c = listToArray(result1_c)

    print(f"Output (Min Heap):     {result1_arr_a}")
    print(f"Output (D&C):          {result1_arr_b}")
    print(f"Output (Brute Force):  {result1_arr_c}")
    expected1 = [1, 1, 2, 3, 4, 4, 5, 6]
    print(f"Expected: {expected1}")
    print(f"âœ… PASS" if result1_arr_a == expected1 else "âŒ FAIL")

    # Test Case 2: Empty lists array
    print("\nğŸ“ Test Case 2: Empty lists array")
    print("-" * 80)
    lists2 = []
    print("Input: []")
    result2_a = mergeKLists_MinHeap(lists2)
    result2_b = mergeKLists_DivideConquer(lists2)
    result2_c = mergeKLists_BruteForce(lists2)
    print(f"Output (Min Heap): {listToArray(result2_a)}")
    print(f"Expected: []")
    print(f"âœ… PASS" if result2_a is None else "âŒ FAIL")

    # Test Case 3: Single empty list
    print("\nğŸ“ Test Case 3: Single empty list")
    print("-" * 80)
    lists3 = [None]
    print("Input: [[]]")
    result3_a = mergeKLists_MinHeap(lists3)
    result3_b = mergeKLists_DivideConquer(lists3)
    result3_c = mergeKLists_BruteForce(lists3)
    print(f"Output (Min Heap): {listToArray(result3_a)}")
    print(f"Expected: []")
    print(f"âœ… PASS" if result3_a is None else "âŒ FAIL")

    # Test Case 4: Single non-empty list
    print("\nğŸ“ Test Case 4: Single non-empty list")
    print("-" * 80)
    lists4 = [createList([1, 2, 3])]
    print("Input: [[1,2,3]]")
    result4_a = mergeKLists_MinHeap(lists4)
    result4_arr_a = listToArray(result4_a)

    lists4_b = [createList([1, 2, 3])]
    result4_b = mergeKLists_DivideConquer(lists4_b)
    result4_arr_b = listToArray(result4_b)

    print(f"Output (Min Heap): {result4_arr_a}")
    print(f"Output (D&C): {result4_arr_b}")
    expected4 = [1, 2, 3]
    print(f"Expected: {expected4}")
    print(f"âœ… PASS" if result4_arr_a == expected4 else "âŒ FAIL")

    # Test Case 5: Lists with duplicates
    print("\nğŸ“ Test Case 5: Lists with duplicates")
    print("-" * 80)
    lists5 = [
        createList([1, 1, 1]),
        createList([1, 1, 1]),
        createList([1, 1, 1])
    ]
    print("Input: [[1,1,1],[1,1,1],[1,1,1]]")
    result5_a = mergeKLists_MinHeap(lists5)
    result5_arr_a = listToArray(result5_a)
    print(f"Output (Min Heap): {result5_arr_a}")
    expected5 = [1, 1, 1, 1, 1, 1, 1, 1, 1]
    print(f"Expected: {expected5}")
    print(f"âœ… PASS" if result5_arr_a == expected5 else "âŒ FAIL")

    # Test Case 6: Lists with negative numbers
    print("\nğŸ“ Test Case 6: Lists with negative numbers")
    print("-" * 80)
    lists6 = [
        createList([-2, -1, -1]),
        createList([-3, -2, 0]),
        createList([-1, 0, 1])
    ]
    print("Input: [[-2,-1,-1],[-3,-2,0],[-1,0,1]]")
    result6_a = mergeKLists_MinHeap(lists6)
    result6_arr_a = listToArray(result6_a)

    lists6_b = [createList([-2, -1, -1]), createList([-3, -2, 0]), createList([-1, 0, 1])]
    result6_b = mergeKLists_DivideConquer(lists6_b)
    result6_arr_b = listToArray(result6_b)

    print(f"Output (Min Heap): {result6_arr_a}")
    print(f"Output (D&C): {result6_arr_b}")
    expected6 = [-3, -2, -2, -1, -1, -1, 0, 0, 1]
    print(f"Expected: {expected6}")
    print(f"âœ… PASS" if result6_arr_a == expected6 else "âŒ FAIL")

    # Test Case 7: Different length lists
    print("\nğŸ“ Test Case 7: Different length lists")
    print("-" * 80)
    lists7 = [
        createList([1, 5, 10, 15]),
        createList([2]),
        createList([3, 7]),
        createList([4, 6, 8, 9])
    ]
    print("Input: [[1,5,10,15],[2],[3,7],[4,6,8,9]]")
    result7_a = mergeKLists_MinHeap(lists7)
    result7_arr_a = listToArray(result7_a)
    print(f"Output (Min Heap): {result7_arr_a}")
    expected7 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15]
    print(f"Expected: {expected7}")
    print(f"âœ… PASS" if result7_arr_a == expected7 else "âŒ FAIL")

    print("\n" + "="*80)
    print("              âœ… ALL TEST CASES COMPLETED!")
    print("="*80)


# ============================================================================
#              ğŸ“ LEARNING SUMMARY & KEY TAKEAWAYS
# ============================================================================

"""
ğŸ¯ WHAT YOU LEARNED:
-------------------
1. K-way merge using min heap achieves O(N log k) time
2. Heap tracks smallest unprocessed node from each list
3. Divide and conquer also achieves O(N log k) with elegant recursion
4. O(N log k) is better than O(N log N) when k << N

ğŸ”‘ KEY PATTERN: "K-Way Merge via Min Heap"
------------------------------------------
This pattern applies when:
- Merging k sorted sequences (lists, arrays, streams)
- Need to process elements in sorted order
- Can't afford O(kN) sequential merging

Used in:
- Merge k Sorted Lists (this problem!)
- Merge k Sorted Arrays
- Find Median from k Sorted Arrays
- External sorting of large datasets
- Log file merging in distributed systems

ğŸ’ª THREE APPROACHES TO MASTER:
-----------------------------
1. MIN HEAP (Optimal - O(N log k))
   - Track k list heads in heap
   - Pop smallest, push next
   - Most common interview solution
   - Space: O(k)

2. DIVIDE AND CONQUER (Optimal - O(N log k))
   - Merge lists in pairs recursively
   - Similar to merge sort
   - Shows strong recursion skills
   - Space: O(log k) recursion depth

3. BRUTE FORCE (Simple - O(N log N))
   - Collect all values, sort, rebuild
   - Easy to code but not optimal
   - Good starting point in interviews

ğŸ¯ INTERVIEW TIPS:
-----------------
1. Clarify: can lists be empty? (Yes, handle null lists)
2. Ask about list size: k small or large?
3. Mention O(N log k) vs O(N log N) difference
4. Explain why min heap, not sorting
5. Discuss reusing nodes vs creating new ones
6. Test with: empty lists, single list, duplicates
7. Consider follow-up: what if lists are arrays?

ğŸ‰ CONGRATULATIONS!
------------------
You now understand the k-way merge pattern using min heap!
Remember: "Heap of heads, pop smallest, push next - O(N log k)!"

ğŸ“Š COMPLEXITY SUMMARY:
---------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Approach           â”‚ Time         â”‚ Space        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Min Heap (Best)    â”‚ O(N log k)   â”‚ O(k)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Divide & Conquer   â”‚ O(N log k)   â”‚ O(log k)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Brute Force        â”‚ O(N log N)   â”‚ O(N)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

N = total nodes, k = number of lists

ğŸ† RECOMMENDED: Use Min Heap for most interviews!
Divide & Conquer is elegant alternative showing recursion mastery!

ğŸ”— RELATED PROBLEMS TO PRACTICE:
-------------------------------
1. LeetCode #23: Merge k Sorted Lists (this problem!)
2. LeetCode #21: Merge Two Sorted Lists
3. LeetCode #88: Merge Sorted Array
4. LeetCode #373: Find K Pairs with Smallest Sums
5. LeetCode #378: Kth Smallest Element in Sorted Matrix
6. LeetCode #632: Smallest Range Covering Elements from K Lists

ğŸ’¡ FINAL TIP:
------------
The k-way merge pattern using min heap is FUNDAMENTAL for distributed systems!
It's used in:
- External sorting (sorting data larger than memory)
- Merging sorted log files from multiple servers
- Database query optimization (merge-join)
- Real-time analytics from multiple data streams

Master this pattern and you'll solve all k-way merge problems!
The key insight: heap size is k (not N), so O(log k) per operation!
This makes it more efficient than sorting when k << N!
"""
