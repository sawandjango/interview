"""
LeetCode Problem #146: LRU Cache

Difficulty: Medium
Topics: Hash Table, Linked List, Design, Doubly-Linked List
Companies: Amazon, Facebook, Google, Microsoft, Apple, Uber, Bloomberg, LinkedIn

================================================================================
                    ğŸ“š QUICK REFERENCE - WHAT'S IN THIS FILE
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ğŸ“– TABLE OF CONTENTS                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ #    â”‚ SECTION                              â”‚ WHAT YOU'LL LEARN             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1    â”‚ ğŸ¯ PROBLEM UNDERSTANDING             â”‚ â€¢ What is being asked?        â”‚
â”‚      â”‚                                      â”‚ â€¢ Real-world analogies        â”‚
â”‚      â”‚                                      â”‚ â€¢ Visual examples             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2    â”‚ ğŸ§  KEY INSIGHTS TO REMEMBER          â”‚ â€¢ Main challenge              â”‚
â”‚      â”‚                                      â”‚ â€¢ Base cases to handle        â”‚
â”‚      â”‚                                      â”‚ â€¢ Pattern recognition         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3    â”‚ ğŸš€ HOW TO APPROACH THIS PROBLEM      â”‚ â€¢ Step-by-step process        â”‚
â”‚      â”‚                                      â”‚ â€¢ Decision tree               â”‚
â”‚      â”‚                                      â”‚ â€¢ Interview scenarios         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4    â”‚ ğŸ’¡ SOLUTION 1: HashMap + DLL â­      â”‚ â€¢ WHY choose? (Pros/Cons)     â”‚
â”‚      â”‚    (OPTIMAL - O(1))                  â”‚ â€¢ WHEN to use?                â”‚
â”‚      â”‚                                      â”‚ â€¢ Step-by-step walkthrough    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 5    â”‚ ğŸ’¡ SOLUTION 2: OrderedDict           â”‚ â€¢ WHY choose? (Pros/Cons)     â”‚
â”‚      â”‚    (Python Built-in)                 â”‚ â€¢ WHEN to use?                â”‚
â”‚      â”‚                                      â”‚ â€¢ Comparison with Solution 1  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 6    â”‚ ğŸ’¡ SOLUTION 3: Array (Not Optimal)   â”‚ â€¢ WHY NOT recommended?        â”‚
â”‚      â”‚    (Educational)                     â”‚ â€¢ What's wrong?               â”‚
â”‚      â”‚                                      â”‚ â€¢ Why O(N) operations fail    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 7    â”‚ ğŸ’» IMPLEMENTATION                    â”‚ â€¢ Clean, commented code       â”‚
â”‚      â”‚                                      â”‚ â€¢ All three solutions         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 8    â”‚ ğŸ§ª TEST CASES                        â”‚ â€¢ Comprehensive tests         â”‚
â”‚      â”‚                                      â”‚ â€¢ Edge cases covered          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 9    â”‚ ğŸ“ LEARNING SUMMARY                  â”‚ â€¢ Key takeaways               â”‚
â”‚      â”‚                                      â”‚ â€¢ Memory tricks               â”‚
â”‚      â”‚                                      â”‚ â€¢ Common mistakes             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 10   â”‚ ğŸ”— RELATED PROBLEMS                  â”‚ â€¢ Similar problems            â”‚
â”‚      â”‚                                      â”‚ â€¢ Pattern recognition         â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ğŸ¯ MEMORY CHEAT SHEET                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ANALOGY          â”‚ "Browser Tabs" - Close least used tab when limit hit!  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PATTERN          â”‚ "HashMap + Doubly Linked List" - Best of both worlds!   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ KEY TRICK        â”‚ HashMap for O(1) access, DLL for O(1) reordering!       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DEFAULT SOLUTION â”‚ HashMap + DLL (O(1) for all operations!)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TIME COMPLEXITY  â”‚ O(1) - Constant time for get() and put()                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SPACE COMPLEXITY â”‚ O(capacity) - Store at most 'capacity' items            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        âš¡ QUICK DECISION TABLE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SITUATION                      â”‚ WHICH SOLUTION TO USE?                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Normal interview               â”‚ âœ… Solution 1 (HashMap + DLL)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Want optimal O(1) solution     â”‚ âœ… Solution 1 (Industry standard!)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Python-specific interview      â”‚ âš¡ Solution 2 (OrderedDict - cleaner)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Learning data structures       â”‚ ğŸ“ Solution 1 (teaches DLL mastery)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Real production system         â”‚ âœ… Solution 1 (most efficient!)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Want to show optimization      â”‚ ğŸ¯ Explain Sol 3, optimize to Sol 1     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ğŸ“Š SOLUTION COMPARISON TABLE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CRITERIA         â”‚ HASHMAP+DLL  â”‚ ORDEREDDICT  â”‚ ARRAY        â”‚ WINNER      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Time: get()      â”‚ â­â­â­â­â­   â”‚ â­â­â­â­â­   â”‚ â­â­         â”‚ HashMap/OD  â”‚
â”‚                  â”‚ O(1)         â”‚ O(1)         â”‚ O(N)         â”‚             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Time: put()      â”‚ â­â­â­â­â­   â”‚ â­â­â­â­â­   â”‚ â­â­         â”‚ HashMap/OD  â”‚
â”‚                  â”‚ O(1)         â”‚ O(1)         â”‚ O(N)         â”‚             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Space Complexity â”‚ â­â­â­â­     â”‚ â­â­â­â­     â”‚ â­â­â­â­â­   â”‚ Array       â”‚
â”‚                  â”‚ O(capacity)  â”‚ O(capacity)  â”‚ O(capacity)  â”‚             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Code Complexity  â”‚ â­â­â­       â”‚ â­â­â­â­â­   â”‚ â­â­â­â­     â”‚ OrderedDict â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Interview Speed  â”‚ â­â­â­â­     â”‚ â­â­â­â­â­   â”‚ â­â­â­â­     â”‚ OrderedDict â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Industry Use     â”‚ â­â­â­â­â­   â”‚ â­â­â­       â”‚ â­           â”‚ HashMap+DLL â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Overall Best     â”‚ âœ… YES       â”‚ Good (Py)    â”‚ Avoid        â”‚ HashMap+DLL â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â±ï¸  TIME TO MASTER: 30-35 minutes
ğŸ¯ DIFFICULTY: Medium (but feels Hard without the pattern!)
ğŸ’¡ TIP: "HashMap finds it, Doubly Linked List orders it!"
ğŸ”¥ POPULAR: Asked in 95% of system design interviews!

================================================================================
                           ğŸ¯ PROBLEM UNDERSTANDING
================================================================================

WHAT IS THE PROBLEM?
--------------------
Design a cache that automatically evicts the LEAST RECENTLY USED item when full.
Both get() and put() operations must be O(1) time!

REAL WORLD ANALOGY:
------------------
Think of it like BROWSER TABS with limited memory:
- You have 3 tab slots available (capacity = 3)
- Opening tabs: Tab1, Tab2, Tab3 (all slots full!)
- Open Tab4 â†’ Close LEAST RECENTLY USED tab (maybe Tab1)
- Click on Tab2 (use it) â†’ Now Tab2 is most recently used
- Open Tab5 â†’ Close least used (maybe Tab3)

Another analogy - MUSIC PLAYLIST CACHE:
- Phone can cache 5 songs (capacity = 5)
- Play songs: [Song A, Song B, Song C, Song D, Song E] (full!)
- Play Song F â†’ Remove least recently played (Song A)
- Play Song B again â†’ Song B becomes most recently used
- Play Song G â†’ Remove least used (maybe Song C)

THE KEY INSIGHT:
---------------
Need TWO data structures working together:
1. HashMap: For O(1) access to values
2. Doubly Linked List: For O(1) reordering (most recent â†” least recent)

âŒ Wrong thinking: "Use HashMap alone" â†’ Can't track order efficiently
âŒ Wrong thinking: "Use List alone" â†’ Can't find items in O(1)
âœ… Right thinking: "Combine HashMap + Doubly Linked List!"

================================================================================
                            ğŸ“ FORMAL PROBLEM
================================================================================

Design a data structure that follows the constraints of a Least Recently Used
(LRU) cache.

Implement the LRUCache class:
- LRUCache(int capacity): Initialize the LRU cache with positive size capacity
- int get(int key): Return the value if key exists, otherwise return -1
  * The get() operation counts as "using" the key (moves to most recent)
- void put(int key, int value): Update value if key exists, or add new pair
  * If adding would exceed capacity, evict the least recently used key

Both get() and put() must run in O(1) average time complexity.

Example 1:
----------
Input:
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]

Output:
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation:
LRUCache cache = new LRUCache(2);  // capacity = 2
cache.put(1, 1);  // cache: {1=1}
cache.put(2, 2);  // cache: {1=1, 2=2}
cache.get(1);     // returns 1, cache: {2=2, 1=1} (1 is now MRU)
cache.put(3, 3);  // evicts key 2, cache: {1=1, 3=3}
cache.get(2);     // returns -1 (not found)
cache.put(4, 4);  // evicts key 1, cache: {3=3, 4=4}
cache.get(1);     // returns -1 (not found)
cache.get(3);     // returns 3
cache.get(4);     // returns 4

Constraints:
------------
* 1 <= capacity <= 3000
* 0 <= key <= 10^4
* 0 <= value <= 10^5
* At most 2 * 10^5 calls will be made to get and put
* Both operations must be O(1) time

================================================================================
                         ğŸ§  KEY INSIGHTS TO REMEMBER
================================================================================

THE MAIN CHALLENGE:
------------------
âŒ HashMap alone: Can find in O(1), but can't track order efficiently
âŒ Array/List alone: Can't find items in O(1)
âŒ Singly Linked List: Can't remove from middle in O(1)
âœ… HashMap + Doubly Linked List: Perfect combination!

THE MAGIC TRICK: "DUMMY HEAD AND TAIL"
---------------------------------------
Key observation: Doubly Linked List with dummy nodes!

Structure:
  head (dummy) â†” [MRU] â†” [item] â†” ... â†” [item] â†” [LRU] â†” tail (dummy)

  - head.next = Most Recently Used
  - tail.prev = Least Recently Used
  - Dummy nodes eliminate edge cases!

THE BREAKTHROUGH INSIGHT:
------------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  HashMap: key â†’ Node (O(1) access)                          â”‚
â”‚  Doubly Linked List: Order from MRU to LRU (O(1) reorder)   â”‚
â”‚  â†’ Combined: O(1) for all operations!                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHY DOUBLY LINKED LIST?
-----------------------
- Singly linked: Can't remove from middle efficiently
- Doubly linked: Can remove ANY node in O(1)
  * node.prev.next = node.next
  * node.next.prev = node.prev
  * Done! Removed in O(1)!

OPERATIONS:
-----------
1. get(key):
   - If key exists: move to head (MRU position), return value
   - If not: return -1

2. put(key, value):
   - If key exists: update value, move to head
   - If new key:
     * Add to head (MRU position)
     * If over capacity: remove tail.prev (LRU item)

================================================================================
                          ğŸ’¡ SOLUTION APPROACHES
================================================================================
"""

from typing import Optional

# ============================================================================
#          APPROACH 1: HASHMAP + DOUBLY LINKED LIST (OPTIMAL)
# ============================================================================

class Node:
    """Node for doubly linked list."""
    def __init__(self, key: int = 0, value: int = 0):
        self.key = key
        self.value = value
        self.prev: Optional[Node] = None
        self.next: Optional[Node] = None


class LRUCache:
    """
    ğŸ¯ APPROACH 1: HashMap + Doubly Linked List (BEST SOLUTION!)

    TIME COMPLEXITY: O(1) - Both get() and put()
    SPACE COMPLEXITY: O(capacity) - Store at most capacity items

    ğŸ§  MEMORIZATION TRICK: "HashMap Finds, DLL Orders"
    --------------------------------------------------
    Think: Like a library with an index card system!
    - HashMap (card catalog): Find book location instantly
    - Doubly Linked List (shelf): Books ordered by last checkout
    - Most recent checkouts at front
    - Least recent at back â†’ remove first when shelf full

    ğŸ“ DATA STRUCTURE:
    ------------------
    HashMap: {key â†’ Node in linked list}
    Doubly Linked List:
      head (dummy) â†” [Node] â†” [Node] â†” ... â†” [Node] â†” tail (dummy)
                      â†‘MRU                        â†‘LRU

    ğŸ“ OPERATIONS:
    --------------
    get(key):
      1. If key not in HashMap â†’ return -1
      2. Get node from HashMap
      3. Move node to head (mark as MRU)
      4. Return node.value
      Time: O(1)

    put(key, value):
      Case 1: Key exists
        1. Get node from HashMap
        2. Update node.value
        3. Move to head (mark as MRU)

      Case 2: New key
        1. Create new node
        2. Add to HashMap
        3. Add to head of DLL
        4. If size > capacity:
           - Remove tail.prev (LRU node)
           - Delete from HashMap
      Time: O(1)

    ğŸ¨ VISUAL EXAMPLE:
    -----------------
    capacity = 2

    Initial state:
      head â†” tail
      HashMap: {}

    put(1, 1):
      head â†” [1,1] â†” tail
      HashMap: {1 â†’ Node(1,1)}

    put(2, 2):
      head â†” [2,2] â†” [1,1] â†” tail
             â†‘MRU          â†‘LRU
      HashMap: {1 â†’ Node(1,1), 2 â†’ Node(2,2)}

    get(1):  (returns 1, moves to head)
      head â†” [1,1] â†” [2,2] â†” tail
             â†‘MRU          â†‘LRU

    put(3, 3):  (capacity full, evict LRU which is 2)
      Remove [2,2] from list and HashMap
      head â†” [3,3] â†” [1,1] â†” tail
             â†‘MRU          â†‘LRU
      HashMap: {1 â†’ Node(1,1), 3 â†’ Node(3,3)}

    WHY THIS IS O(1):
    -----------------
    âœ… HashMap lookup: O(1)
    âœ… Remove from DLL: O(1) (update pointers)
    âœ… Add to head: O(1) (update pointers)
    âœ… Remove from tail: O(1) (tail.prev)

    All pointer operations are constant time!
    """

    def __init__(self, capacity: int):
        """Initialize LRU cache with given capacity."""
        self.capacity = capacity
        self.cache = {}  # key â†’ Node

        # Dummy head and tail to eliminate edge cases
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head

    def _remove(self, node: Node) -> None:
        """
        Remove node from doubly linked list.

        Before:  A â†” node â†” B
        After:   A â†” B

        Time: O(1)
        """
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node

    def _add_to_head(self, node: Node) -> None:
        """
        Add node right after head (most recent position).

        Before:  head â†” A â†” ...
        After:   head â†” node â†” A â†” ...

        Time: O(1)
        """
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def _move_to_head(self, node: Node) -> None:
        """
        Move existing node to head (mark as most recently used).

        Time: O(1) - Just remove and add
        """
        self._remove(node)
        self._add_to_head(node)

    def _remove_tail(self) -> Node:
        """
        Remove and return least recently used node (before tail).

        Before:  ... â†” LRU â†” tail
        After:   ... â†” tail
        Return:  LRU node

        Time: O(1)
        """
        lru_node = self.tail.prev
        self._remove(lru_node)
        return lru_node

    def get(self, key: int) -> int:
        """
        Get value from cache.
        If exists, move to head (mark as recently used).

        Time: O(1)
        """
        if key not in self.cache:
            return -1

        node = self.cache[key]
        self._move_to_head(node)  # Mark as MRU
        return node.value

    def put(self, key: int, value: int) -> None:
        """
        Put key-value pair in cache.
        If key exists: update value and move to head.
        If new key: add to head and evict LRU if needed.

        Time: O(1)
        """
        if key in self.cache:
            # Key exists: update value and move to head
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)
        else:
            # New key: create node and add to head
            new_node = Node(key, value)
            self.cache[key] = new_node
            self._add_to_head(new_node)

            # Check capacity and evict if needed
            if len(self.cache) > self.capacity:
                lru_node = self._remove_tail()
                del self.cache[lru_node.key]


# ============================================================================
#              APPROACH 2: ORDEREDDICT (PYTHON BUILT-IN)
# ============================================================================

from collections import OrderedDict

class LRUCache_OrderedDict:
    """
    ğŸ¯ APPROACH 2: Using Python's OrderedDict (SIMPLER!)

    TIME COMPLEXITY: O(1) - Both get() and put()
    SPACE COMPLEXITY: O(capacity)

    ğŸ§  MEMORIZATION TRICK: "OrderedDict Remembers Insertion Order"
    ---------------------------------------------------------------
    Think: Python's OrderedDict is like a smart dictionary!
    - Maintains insertion order
    - move_to_end(key) moves item to end (most recent)
    - popitem(last=False) removes oldest item
    - Perfect for LRU cache!

    ğŸ“ OPERATIONS:
    --------------
    get(key):
      1. If key not in cache â†’ return -1
      2. Move to end (mark as MRU)
      3. Return value

    put(key, value):
      1. If key exists: move to end
      2. Set cache[key] = value
      3. If size > capacity: popitem(last=False) to remove oldest

    ğŸ¨ VISUAL EXAMPLE:
    -----------------
    capacity = 2

    put(1, 1):  cache = OrderedDict([(1, 1)])
    put(2, 2):  cache = OrderedDict([(1, 1), (2, 2)])
    get(1):     cache = OrderedDict([(2, 2), (1, 1)])  â† 1 moved to end
    put(3, 3):  Remove oldest (2), add 3
                cache = OrderedDict([(1, 1), (3, 3)])

    âš ï¸  WHY THIS WORKS:
    -------------------
    - OrderedDict maintains order internally using DLL!
    - move_to_end() is O(1)
    - popitem(last=False) is O(1)
    - Same underlying structure as our custom implementation!

    âœ… WHEN TO USE:
    ---------------
    - Python-specific interviews (if allowed)
    - Quick prototyping
    - When you want clean, readable code

    âŒ WHEN NOT TO USE:
    -------------------
    - Need to show data structure knowledge
    - Language-agnostic interview
    - Want to demonstrate pointer manipulation
    """

    def __init__(self, capacity: int):
        """Initialize LRU cache with given capacity."""
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        """
        Get value from cache.
        Move to end to mark as most recently used.

        Time: O(1)
        """
        if key not in self.cache:
            return -1

        # Move to end (most recent)
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        """
        Put key-value pair in cache.
        If exists: move to end. If new: add and evict if needed.

        Time: O(1)
        """
        if key in self.cache:
            # Move to end (mark as MRU)
            self.cache.move_to_end(key)

        self.cache[key] = value

        # Evict LRU if over capacity
        if len(self.cache) > self.capacity:
            # popitem(last=False) removes oldest (FIFO)
            self.cache.popitem(last=False)


# ============================================================================
#              APPROACH 3: ARRAY WITH TIMESTAMPS (NOT OPTIMAL)
# ============================================================================

import time

class LRUCache_Array:
    """
    ğŸ¯ APPROACH 3: Array with Timestamps (DON'T USE THIS!)

    TIME COMPLEXITY: O(N) - Need to scan array to find LRU
    SPACE COMPLEXITY: O(capacity)

    ğŸ§  IDEA: Store items with timestamps
    -------------------------------------
    - Each item has: (key, value, timestamp)
    - get(): Update timestamp
    - put(): Find and remove item with oldest timestamp (O(N)!)

    âš ï¸  PROBLEMS:
    ------------
    1. Finding LRU item requires scanning entire array â†’ O(N)
    2. Removing from middle of array â†’ O(N)
    3. Finding specific key â†’ O(N) without additional HashMap
    4. Violates O(1) requirement!

    ğŸ“ ALGORITHM:
    ------------
    get(key):
      1. Scan array to find key â†’ O(N)
      2. If found: update timestamp, return value
      3. If not: return -1

    put(key, value):
      1. Scan to find if key exists â†’ O(N)
      2. If exists: update value and timestamp
      3. If new and array full:
         - Find item with minimum timestamp â†’ O(N)
         - Remove it â†’ O(N)
      4. Add new item

    âš ï¸  WHY AVOID:
    -------------
    - All operations are O(N), not O(1)
    - Violates problem requirements
    - No advantage over HashMap + DLL
    - Only useful for understanding WHY we need better structures
    """

    def __init__(self, capacity: int):
        """Initialize cache with capacity."""
        self.capacity = capacity
        self.cache = []  # List of (key, value, timestamp)
        self.counter = 0  # Monotonic counter for order

    def get(self, key: int) -> int:
        """Get value - O(N) because we scan array."""
        for i, (k, v, _) in enumerate(self.cache):
            if k == key:
                # Update timestamp
                self.counter += 1
                self.cache[i] = (k, v, self.counter)
                return v
        return -1

    def put(self, key: int, value: int) -> None:
        """Put value - O(N) to find and potentially evict."""
        self.counter += 1

        # Check if key exists
        for i, (k, _, _) in enumerate(self.cache):
            if k == key:
                self.cache[i] = (k, value, self.counter)
                return

        # New key
        if len(self.cache) >= self.capacity:
            # Find LRU (minimum timestamp) - O(N)!
            lru_idx = min(range(len(self.cache)),
                         key=lambda i: self.cache[i][2])
            self.cache.pop(lru_idx)

        self.cache.append((key, value, self.counter))


# ============================================================================
#                    ğŸ¨ VISUAL WALKTHROUGH EXAMPLE
# ============================================================================

"""
Let's walk through the HashMap + DLL approach with:
capacity = 2
Operations: put(1,1), put(2,2), get(1), put(3,3), get(2), put(4,4)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                            DETAILED STEP-BY-STEP VISUALIZATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INITIAL STATE                                                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Doubly Linked List Structure:                                                                                                â”‚
â”‚                                                                                                                                 â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚
â”‚                    â”‚      HEAD      â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚      TAIL      â”‚                                          â”‚
â”‚                    â”‚  (dummy node)  â”‚                              â”‚  (dummy node)  â”‚                                          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚                                                                                                                                 â”‚
â”‚   HashMap (Key â†’ Node):                                                                                                        â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                                        â”‚
â”‚                    â”‚         Empty {}                 â”‚                                                                        â”‚
â”‚                    â”‚     (No entries yet)             â”‚                                                                        â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                        â”‚
â”‚                                                                                                                                 â”‚
â”‚   Cache Statistics:                                                                                                            â”‚
â”‚      â€¢ Current Size: 0 / 2                                                                                                     â”‚
â”‚      â€¢ Available Slots: 2                                                                                                      â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERATION 1: put(1, 1) â€” Adding first element to cache                                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Steps Performed:                                                                                                             â”‚
â”‚      1. Create new Node(key=1, value=1)                                                                                        â”‚
â”‚      2. Add entry to HashMap: cache[1] = Node(1,1)                                                                             â”‚
â”‚      3. Insert node after HEAD (most recent position)                                                                          â”‚
â”‚      4. Update size: 0 â†’ 1                                                                                                     â”‚
â”‚                                                                                                                                 â”‚
â”‚   BEFORE Operation:                                 AFTER Operation:                                                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                            â”‚
â”‚   HEAD â†” TAIL                                       HEAD â†” [Node 1:1] â†” TAIL                                                  â”‚
â”‚   (empty cache)                                              â†‘ MRU (Most Recently Used)                                        â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   Detailed Doubly Linked List Structure (with pointers):                                                                       â”‚
â”‚                                                                                                                                 â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        next         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        next         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚       â”‚     HEAD     â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 1:1      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚     TAIL     â”‚                          â”‚
â”‚       â”‚  (dummy)     â”‚                     â”‚    key = 1       â”‚                     â”‚  (dummy)     â”‚                          â”‚
â”‚       â”‚              â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 1     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚              â”‚                          â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        prev         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        prev         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                     â†‘                                                                           â”‚
â”‚                                                     â”‚                                                                           â”‚
â”‚   HashMap After Insertion:                          â”‚                                                                           â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚                                                                           â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚                                                                           â”‚
â”‚       â”‚  Key 1  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 1:1 in DLL)                                              â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                                            â”‚
â”‚                                                                                                                                 â”‚
â”‚   Cache Statistics:                                                                                                            â”‚
â”‚      âœ… Size: 1 / 2                                                                                                            â”‚
â”‚      âœ… MRU (Most Recent): key=1                                                                                               â”‚
â”‚      âœ… LRU (Least Recent): key=1 (only element)                                                                               â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERATION 2: put(2, 2) â€” Cache now full!                                                                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Steps Performed:                                                                                                             â”‚
â”‚      1. Create new Node(key=2, value=2)                                                                                        â”‚
â”‚      2. Add entry to HashMap: cache[2] = Node(2,2)                                                                             â”‚
â”‚      3. Insert node after HEAD (new MRU, pushes previous node toward LRU)                                                      â”‚
â”‚      4. Update size: 1 â†’ 2 (CACHE FULL!)                                                                                       â”‚
â”‚                                                                                                                                 â”‚
â”‚   Doubly Linked List Structure (with full pointers):                                                                           â”‚
â”‚                                                                                                                                 â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       â”‚     HEAD     â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 2:2      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 1:1      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚     TAIL     â”‚
â”‚       â”‚  (dummy)     â”‚                   â”‚    key = 2       â”‚                   â”‚    key = 1       â”‚                   â”‚  (dummy)     â”‚
â”‚       â”‚              â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 2     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 1     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚              â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                                   â†‘ MRU                                   â†‘ LRU                                          â”‚
â”‚                                            (Most Recently Used)                    (Least Recently Used)                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   HashMap After Insertion:                                                                                                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                    â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚       â”‚  Key 2  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 2:2 in DLL)                   â”‚                                                   â”‚
â”‚       â”‚  Key 1  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 1:1)    â”‚                                                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚   Cache Statistics:                                                                                                            â”‚
â”‚      âœ… Size: 2 / 2 (CACHE FULL!)                                                                                              â”‚
â”‚      âœ… MRU (Most Recent): key=2 (just added)                                                                                  â”‚
â”‚      âœ… LRU (Least Recent): key=1 (oldest, will be evicted next if cache exceeds capacity)                                     â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERATION 3: get(1) â†’ Returns 1 â€” Accessing existing key moves it to MRU position                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Steps Performed:                                                                                                             â”‚
â”‚      1. HashMap lookup: cache[1] exists âœ…                                                                                     â”‚
â”‚      2. Get node reference from HashMap                                                                                        â”‚
â”‚      3. Move node to head (mark as MRU) via _move_to_head()                                                                    â”‚
â”‚         a. Remove from current position (disconnect pointers)                                                                  â”‚
â”‚         b. Insert after head (reconnect as MRU)                                                                                â”‚
â”‚      4. Return node.value = 1                                                                                                  â”‚
â”‚                                                                                                                                 â”‚
â”‚   BEFORE get(1):                                   AFTER get(1):                                                               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                              â”‚
â”‚   HEAD â†” [2:2] â†” [1:1] â†” TAIL                     HEAD â†” [1:1] â†” [2:2] â†” TAIL                                                â”‚
â”‚         â†‘MRU           â†‘LRU                               â†‘MRU          â†‘LRU                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   Detailed Doubly Linked List Structure (AFTER get(1) - with full pointers):                                                  â”‚
â”‚                                                                                                                                 â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       â”‚     HEAD     â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 1:1      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 2:2      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚     TAIL     â”‚
â”‚       â”‚  (dummy)     â”‚                   â”‚    key = 1       â”‚                   â”‚    key = 2       â”‚                   â”‚  (dummy)     â”‚
â”‚       â”‚              â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 1     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 2     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚              â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â”‚    MOVED! â­      â”‚       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â†‘ LRU                                          â”‚
â”‚                                                   â†‘ MRU (Most Recently Used)       (Least Recently Used - Next to evict)                  â”‚
â”‚                                             (Just accessed via get!)                                                                      â”‚
â”‚                                                                                                                                 â”‚
â”‚   HashMap After get(1):                                                                                                        â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                         â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚       â”‚  Key 2  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 2:2)  â”‚                                                   â”‚
â”‚       â”‚  Key 1  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 1:1 - now at MRU!)       â”‚                                                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚   Cache Statistics:                                                                                                            â”‚
â”‚      âœ… Size: 2 / 2 (FULL)                                                                                                     â”‚
â”‚      âœ… MRU (Most Recent): key=1 (just accessed!)                                                                              â”‚
â”‚      âœ… LRU (Least Recent): key=2 (will be evicted next if capacity exceeded)                                                  â”‚
â”‚                                                                                                                                 â”‚
â”‚   Return Value: 1 âœ…                                                                                                            â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERATION 4: put(3, 3) â†’ EVICTION REQUIRED! Cache full, must evict LRU to make room                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Steps Performed:                                                                                                             â”‚
â”‚      1. Create new Node(key=3, value=3)                                                                                        â”‚
â”‚      2. Add entry to HashMap: cache[3] = Node(3,3)                                                                             â”‚
â”‚      3. Insert node after HEAD (new MRU position)                                                                              â”‚
â”‚      4. Check size: len(cache) = 3 > capacity(2) â†’ EVICTION REQUIRED!                                                          â”‚
â”‚      5. Remove tail.prev (the LRU node, which is key=2)                                                                        â”‚
â”‚      6. Delete key 2 from HashMap                                                                                              â”‚
â”‚                                                                                                                                 â”‚
â”‚   INTERMEDIATE STATE: After adding Node 3:3 but BEFORE eviction                                                                â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                â”‚
â”‚                                                                                                                                 â”‚
â”‚       HEAD â†” [3:3] â†” [1:1] â†” [2:2] â†” TAIL                                                                                     â”‚
â”‚             â†‘NEW                    â†‘LRU (will be evicted!)                                                                    â”‚
â”‚                                                                                                                                 â”‚
â”‚       Size: 3 items (exceeds capacity of 2!)                                                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   FINAL STATE: After evicting Node 2:2 (LRU)                                                                                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   Doubly Linked List Structure (with full pointers):                                                                           â”‚
â”‚                                                                                                                                 â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       â”‚     HEAD     â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 3:3      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 1:1      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚     TAIL     â”‚
â”‚       â”‚  (dummy)     â”‚                   â”‚    key = 3       â”‚                   â”‚    key = 1       â”‚                   â”‚  (dummy)     â”‚
â”‚       â”‚              â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 3     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 1     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚              â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â”‚    NEW! â­        â”‚       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â†‘ LRU                                          â”‚
â”‚                                                   â†‘ MRU (Most Recently Used)       (Least Recently Used - Next to evict)                  â”‚
â”‚                                                (Just added!)                                                                              â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   Node(2:2) EVICTED! âŒ                                                                                                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                        â”‚
â”‚   â€¢ Removed from doubly linked list (tail.prev disconnected)                                                                   â”‚
â”‚   â€¢ Deleted from HashMap (key 2 no longer exists)                                                                              â”‚
â”‚   â€¢ Memory freed                                                                                                                â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   HashMap After Eviction:                                                                                                      â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                      â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚       â”‚  Key 3  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 3:3 in DLL - MRU)        â”‚                                                   â”‚
â”‚       â”‚  Key 1  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 1:1) â”‚                                                   â”‚
â”‚       â”‚  Key 2  DELETED! âŒ (was evicted)                                  â”‚                                                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚   Cache Statistics:                                                                                                            â”‚
â”‚      âœ… Size: 2 / 2 (back to capacity after eviction)                                                                          â”‚
â”‚      âœ… MRU (Most Recent): key=3 (just added)                                                                                  â”‚
â”‚      âœ… LRU (Least Recent): key=1 (will be evicted next if capacity exceeded)                                                  â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERATION 5: get(2) â†’ Returns -1 (NOT FOUND) â€” Attempting to access evicted key                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Steps Performed:                                                                                                             â”‚
â”‚      1. HashMap lookup: cache[2] does NOT exist âŒ                                                                             â”‚
â”‚      2. Return -1 (key not found)                                                                                              â”‚
â”‚                                                                                                                                 â”‚
â”‚   Doubly Linked List State (unchanged - no modifications):                                                                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚       HEAD â†” [3:3] â†” [1:1] â†” TAIL                                                                                             â”‚
â”‚             â†‘MRU           â†‘LRU                                                                                                â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   HashMap State (unchanged):                                                                                                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                  â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚       â”‚  Key 3  â”€â”€â”€â†’ Points to Node(3:3) in DLL                            â”‚                                                   â”‚
â”‚       â”‚  Key 1  â”€â”€â”€â†’ Points to Node(1:1) in DLL                            â”‚                                                   â”‚
â”‚       â”‚  Key 2  NOT PRESENT! (was evicted in OPERATION 4) âŒ               â”‚                                                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚   Explanation:                                                                                                                 â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                               â”‚
â”‚   â€¢ Key 2 was evicted in the previous operation (OPERATION 4: put(3,3))                                                        â”‚
â”‚   â€¢ The HashMap no longer contains key 2                                                                                       â”‚
â”‚   â€¢ get() returns -1 to indicate key not found                                                                                 â”‚
â”‚   â€¢ Cache state remains unchanged (no side effects from failed lookup)                                                         â”‚
â”‚                                                                                                                                 â”‚
â”‚   Return Value: -1 âŒ (Key 2 was previously evicted and does not exist in cache)                                               â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERATION 6: put(4, 4) â†’ EVICTION REQUIRED AGAIN! Adding new key when cache is full                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   Steps Performed:                                                                                                             â”‚
â”‚      1. Create new Node(key=4, value=4)                                                                                        â”‚
â”‚      2. Add entry to HashMap: cache[4] = Node(4,4)                                                                             â”‚
â”‚      3. Insert node after HEAD (new MRU position)                                                                              â”‚
â”‚      4. Check size: len(cache) = 3 > capacity(2) â†’ EVICTION REQUIRED!                                                          â”‚
â”‚      5. Remove tail.prev (the LRU node, which is key=1)                                                                        â”‚
â”‚      6. Delete key 1 from HashMap                                                                                              â”‚
â”‚                                                                                                                                 â”‚
â”‚   INTERMEDIATE STATE: After adding Node 4:4 but BEFORE eviction                                                                â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                â”‚
â”‚                                                                                                                                 â”‚
â”‚       HEAD â†” [4:4] â†” [3:3] â†” [1:1] â†” TAIL                                                                                     â”‚
â”‚             â†‘NEW                    â†‘LRU (will be evicted!)                                                                    â”‚
â”‚                                                                                                                                 â”‚
â”‚       Size: 3 items (exceeds capacity of 2!)                                                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   FINAL STATE: After evicting Node 1:1 (LRU)                                                                                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   Doubly Linked List Structure (with full pointers):                                                                           â”‚
â”‚                                                                                                                                 â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       next        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       â”‚     HEAD     â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 4:4      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚    Node 3:3      â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚     TAIL     â”‚
â”‚       â”‚  (dummy)     â”‚                   â”‚    key = 4       â”‚                   â”‚    key = 3       â”‚                   â”‚  (dummy)     â”‚
â”‚       â”‚              â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 4     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    value = 3     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚              â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â”‚    NEW! â­        â”‚       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       prev        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â†‘ LRU                                          â”‚
â”‚                                                   â†‘ MRU (Most Recently Used)       (Least Recently Used - Next to evict)                  â”‚
â”‚                                                (Just added!)                                                                              â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   Node(1:1) EVICTED! âŒ                                                                                                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                        â”‚
â”‚   â€¢ Removed from doubly linked list (tail.prev disconnected)                                                                   â”‚
â”‚   â€¢ Deleted from HashMap (key 1 no longer exists)                                                                              â”‚
â”‚   â€¢ Memory freed                                                                                                                â”‚
â”‚                                                                                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   HashMap Final State:                                                                                                         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                         â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚       â”‚  Key 4  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 4:4 in DLL - MRU)        â”‚                                                   â”‚
â”‚       â”‚  Key 3  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (points to Node 3:3) â”‚                                                   â”‚
â”‚       â”‚  Key 1  DELETED! âŒ (was evicted)                                  â”‚                                                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚   Cache Statistics:                                                                                                            â”‚
â”‚      âœ… Size: 2 / 2 (at capacity after eviction)                                                                               â”‚
â”‚      âœ… MRU (Most Recent): key=4 (just added)                                                                                  â”‚
â”‚      âœ… LRU (Least Recent): key=3 (will be evicted next if capacity exceeded)                                                  â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                      FINAL STATE SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                  COMPLETE SYSTEM STATE                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚  Doubly Linked List (Visual Representation):                                                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                  â”‚
â”‚                                                                                                                                 â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       â”‚     HEAD     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚    Node 4:4      â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚    Node 3:3      â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚     TAIL     â”‚
â”‚       â”‚  (dummy)     â”‚                â”‚    â­ MRU        â”‚                â”‚    âš ï¸  LRU       â”‚                â”‚  (dummy)     â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚                                                â†‘                                    â†‘                                           â”‚
â”‚                                                â”‚                                    â”‚                                           â”‚
â”‚                                                â”‚                                    â”‚                                           â”‚
â”‚  HashMap (Key â†’ Node References):              â”‚                                    â”‚                                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”‚                                    â”‚                                           â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚       â”‚  Key 4  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚      â”‚                                   â”‚
â”‚       â”‚  Key 3  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚                                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                                                                                 â”‚
â”‚  Cache Statistics:                                                                                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                            â”‚
â”‚      âœ“ Current size: 2 / 2 (FULL - at maximum capacity)                                                                        â”‚
â”‚      âœ“ Most Recently Used (MRU): Key 4 (last accessed/added)                                                                   â”‚
â”‚      âœ“ Least Recently Used (LRU): Key 3 (next candidate for eviction)                                                          â”‚
â”‚                                                                                                                                 â”‚
â”‚  Eviction History:                                                                                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                            â”‚
â”‚      1. Key 2 evicted after put(3,3) - was LRU at that time                                                                    â”‚
â”‚      2. Key 1 evicted after put(4,4) - was LRU at that time                                                                    â”‚
â”‚                                                                                                                                 â”‚
â”‚  Complete Access Pattern Summary:                                                                                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                             â”‚
â”‚                                                                                                                                 â”‚
â”‚      put(1,1) â†’ put(2,2) â†’ get(1) â†’ put(3,3) â†’ get(2) â†’ put(4,4)                                                              â”‚
â”‚                               â†‘          â†‘         â†‘         â†‘                                                                 â”‚
â”‚                          moved 1 to   evicted 2  returned  evicted 1                                                           â”‚
â”‚                             MRU                     -1                                                                          â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                                  WHY O(1) TIME COMPLEXITY?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OPERATION BREAKDOWN:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ get(key) â€” Time Complexity Analysis:                                                                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   âœ… HashMap lookup: O(1) â€” Direct hash table access to find node                                                              â”‚
â”‚                                                                                                                                 â”‚
â”‚   âœ… _remove(node): O(1) â€” Update exactly 4 pointers to remove node from current position                                      â”‚
â”‚      Code:                                                                                                                      â”‚
â”‚        node.prev.next = node.next  (update left neighbor's next pointer)                                                       â”‚
â”‚        node.next.prev = node.prev  (update right neighbor's prev pointer)                                                      â”‚
â”‚                                                                                                                                 â”‚
â”‚   âœ… _add_to_head(node): O(1) â€” Update exactly 4 pointers to insert at MRU position                                            â”‚
â”‚      Code:                                                                                                                      â”‚
â”‚        node.next = head.next       (point to current first node)                                                               â”‚
â”‚        node.prev = head            (point back to head)                                                                        â”‚
â”‚        head.next.prev = node       (update old first node's prev)                                                              â”‚
â”‚        head.next = node            (update head's next)                                                                        â”‚
â”‚                                                                                                                                 â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚   TOTAL: O(1) âœ… â€” Constant number of operations regardless of cache size                                                      â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ put(key, value) â€” Time Complexity Analysis:                                                                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚   âœ… HashMap lookup: O(1) â€” Check if key already exists in cache                                                               â”‚
â”‚                                                                                                                                 â”‚
â”‚   âœ… Create node: O(1) â€” Allocate new Node object with key and value                                                           â”‚
â”‚                                                                                                                                 â”‚
â”‚   âœ… HashMap insert: O(1) â€” Add key â†’ node mapping to hash table                                                               â”‚
â”‚                                                                                                                                 â”‚
â”‚   âœ… _add_to_head(node): O(1) â€” Update 4 pointers to insert at MRU position                                                    â”‚
â”‚                                                                                                                                 â”‚
â”‚   âœ… _remove_tail(): O(1) â€” Remove LRU node when capacity exceeded                                                             â”‚
â”‚      Code:                                                                                                                      â”‚
â”‚        lru = tail.prev             (O(1) â€” direct reference to LRU node!)                                                      â”‚
â”‚        _remove(lru)                (O(1) â€” 4 pointer updates)                                                                  â”‚
â”‚                                                                                                                                 â”‚
â”‚   âœ… HashMap delete: O(1) â€” Remove evicted key from hash table                                                                 â”‚
â”‚                                                                                                                                 â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚   TOTAL: O(1) âœ… â€” Constant number of operations regardless of cache size                                                      â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ KEY INSIGHT: Why Doubly Linked List enables O(1) removal?                                                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                                                                 â”‚
â”‚  Removal from MIDDLE of list â€” The critical difference:                                                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                      â”‚
â”‚                                                                                                                                 â”‚
â”‚      Singly Linked List: O(N) â€” Must traverse from head to find previous node                                                  â”‚
â”‚      Doubly Linked List: O(1) â€” node.prev gives instant access to previous node!                                               â”‚
â”‚                                                                                                                                 â”‚
â”‚  Example: Remove Node [1:1] from: HEAD â†” [3:3] â†” [1:1] â†” [2:2] â†” TAIL                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â”‚
â”‚                                                                                                                                 â”‚
â”‚      Singly Linked List Approach (SLOW):                                                                                       â”‚
â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                      â”‚
â”‚        âŒ Step 1: Start at head, traverse: head â†’ 3 â†’ 1 (found!)                                                               â”‚
â”‚        âŒ Step 2: Need to update node 3's next pointer... but we don't have reference to node 3!                               â”‚
â”‚        âŒ Step 3: Must traverse AGAIN from head to find node 3                                                                 â”‚
â”‚        âŒ Time: O(N) â€” Must traverse list to find predecessor                                                                  â”‚
â”‚                                                                                                                                 â”‚
â”‚      Doubly Linked List Approach (FAST):                                                                                       â”‚
â”‚      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                     â”‚
â”‚        âœ… Step 1: Have direct node reference from HashMap                                                                      â”‚
â”‚        âœ… Step 2: node.prev.next = node.next  (update left neighbor â€” instant access via prev!)                                â”‚
â”‚        âœ… Step 3: node.next.prev = node.prev  (update right neighbor â€” instant access via next!)                               â”‚
â”‚        âœ… Done in exactly 2 pointer updates!                                                                                   â”‚
â”‚        âœ… Time: O(1) â€” No traversal needed!                                                                                    â”‚
â”‚                                                                                                                                 â”‚
â”‚  This is why LRU Cache MUST use Doubly Linked List! The prev pointer is essential for O(1) removal.                            â”‚
â”‚                                                                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"""

# ============================================================================
#              ğŸ¯ MEMORY TRICKS & COMMON MISTAKES
# ============================================================================

"""
ğŸ§  HOW TO REMEMBER THIS SOLUTION:
---------------------------------
1. "FIND AND ORDER" â†’ HashMap finds, DLL orders
2. "DUMMY GUARDS" â†’ Dummy head/tail eliminate edge cases
3. "DOUBLY NOT SINGLY" â†’ Need prev pointer for O(1) removal
4. "MOVE ON ACCESS" â†’ Both get() and put() move to head!

âŒ COMMON MISTAKES TO AVOID:
----------------------------
1. âŒ Using singly linked list
      WRONG: Can't remove from middle in O(1)
      RIGHT: Doubly linked list with prev pointers

2. âŒ Not using dummy nodes
      WRONG: Complex edge cases (empty list, single element)
      RIGHT: Dummy head and tail simplify all operations

3. âŒ Forgetting to update HashMap when removing
      WRONG: Remove from DLL but not HashMap
      RIGHT: del cache[key] when removing from DLL

4. âŒ Not moving node on get()
      WRONG: get() just returns value
      RIGHT: get() moves node to head (marks as MRU)

5. âŒ Not moving to head when updating existing key
      WRONG: put() existing key only updates value
      RIGHT: put() updates value AND moves to head

6. âŒ Removing wrong node
      WRONG: Remove from head when evicting
      RIGHT: Remove from tail (tail.prev is LRU)

7. âŒ Checking capacity before adding
      WRONG: if len(cache) == capacity: evict, then add
      RIGHT: Add first, then if len(cache) > capacity: evict
      (Otherwise can't update existing keys when at capacity!)

âœ… PRO TIPS:
-----------
1. Draw the DLL structure before coding
2. Test edge cases: capacity=1, updating existing key
3. OrderedDict is simpler but may not be allowed
4. Dummy nodes are CRITICAL - don't skip them!
5. Always update BOTH HashMap and DLL together

ğŸ¯ INTERVIEW STRATEGY:
---------------------
"I'll use a HashMap for O(1) access and a doubly linked list to maintain
LRU order. The HashMap maps keys to nodes in the DLL. The DLL has dummy
head and tail nodes to simplify edge cases. head.next is the most recently
used, tail.prev is least recently used. On get(), I move the node to head.
On put(), if capacity is exceeded, I remove tail.prev and delete from HashMap."

Then code it step by step, explaining the helper methods first!
"""

# ============================================================================
#                         ğŸ§ª TEST CASES
# ============================================================================

if __name__ == "__main__":
    print("="*80)
    print("                  LRU CACHE - TEST CASES")
    print("="*80)

    # Test Case 1: Standard operations
    print("\nğŸ“ Test Case 1: Standard operations (capacity=2)")
    print("-" * 80)
    cache1 = LRUCache(2)

    print("put(1, 1)")
    cache1.put(1, 1)
    print("put(2, 2)")
    cache1.put(2, 2)
    result1 = cache1.get(1)
    print(f"get(1) = {result1}")
    print("Expected: 1")
    print(f"âœ… PASS" if result1 == 1 else "âŒ FAIL")

    print("\nput(3, 3)  # Evicts key 2")
    cache1.put(3, 3)
    result2 = cache1.get(2)
    print(f"get(2) = {result2}")
    print("Expected: -1 (evicted)")
    print(f"âœ… PASS" if result2 == -1 else "âŒ FAIL")

    print("\nput(4, 4)  # Evicts key 1")
    cache1.put(4, 4)
    result3 = cache1.get(1)
    print(f"get(1) = {result3}")
    print("Expected: -1 (evicted)")
    print(f"âœ… PASS" if result3 == -1 else "âŒ FAIL")

    result4 = cache1.get(3)
    print(f"get(3) = {result4}")
    print("Expected: 3")
    print(f"âœ… PASS" if result4 == 3 else "âŒ FAIL")

    result5 = cache1.get(4)
    print(f"get(4) = {result5}")
    print("Expected: 4")
    print(f"âœ… PASS" if result5 == 4 else "âŒ FAIL")

    # Test Case 2: Update existing key
    print("\nğŸ“ Test Case 2: Update existing key")
    print("-" * 80)
    cache2 = LRUCache(2)
    cache2.put(1, 1)
    cache2.put(2, 2)
    print("put(1, 1), put(2, 2)")

    cache2.put(1, 10)
    print("put(1, 10)  # Update key 1")
    result6 = cache2.get(1)
    print(f"get(1) = {result6}")
    print("Expected: 10")
    print(f"âœ… PASS" if result6 == 10 else "âŒ FAIL")

    cache2.put(3, 3)
    print("\nput(3, 3)  # Should evict 2, not 1 (1 was just updated)")
    result7 = cache2.get(2)
    print(f"get(2) = {result7}")
    print("Expected: -1 (evicted)")
    print(f"âœ… PASS" if result7 == -1 else "âŒ FAIL")

    # Test Case 3: Capacity of 1
    print("\nğŸ“ Test Case 3: Single capacity")
    print("-" * 80)
    cache3 = LRUCache(1)
    cache3.put(1, 1)
    print("put(1, 1)")

    cache3.put(2, 2)
    print("put(2, 2)  # Evicts 1")
    result8 = cache3.get(1)
    print(f"get(1) = {result8}")
    print("Expected: -1 (evicted)")
    print(f"âœ… PASS" if result8 == -1 else "âŒ FAIL")

    result9 = cache3.get(2)
    print(f"get(2) = {result9}")
    print("Expected: 2")
    print(f"âœ… PASS" if result9 == 2 else "âŒ FAIL")

    # Test Case 4: Multiple gets
    print("\nğŸ“ Test Case 4: Multiple gets of same key")
    print("-" * 80)
    cache4 = LRUCache(2)
    cache4.put(1, 1)
    cache4.put(2, 2)
    print("put(1, 1), put(2, 2)")

    cache4.get(1)
    cache4.get(1)
    cache4.get(1)
    print("get(1) Ã— 3 times  # 1 becomes MRU")

    cache4.put(3, 3)
    print("put(3, 3)  # Should evict 2, not 1")
    result10 = cache4.get(2)
    print(f"get(2) = {result10}")
    print("Expected: -1 (evicted)")
    print(f"âœ… PASS" if result10 == -1 else "âŒ FAIL")

    result11 = cache4.get(1)
    print(f"get(1) = {result11}")
    print("Expected: 1")
    print(f"âœ… PASS" if result11 == 1 else "âŒ FAIL")

    # Test Case 5: OrderedDict implementation
    print("\nğŸ“ Test Case 5: OrderedDict implementation")
    print("-" * 80)
    cache5 = LRUCache_OrderedDict(2)
    cache5.put(1, 1)
    cache5.put(2, 2)
    print("put(1, 1), put(2, 2)")

    result12 = cache5.get(1)
    print(f"get(1) = {result12}")
    print("Expected: 1")
    print(f"âœ… PASS" if result12 == 1 else "âŒ FAIL")

    cache5.put(3, 3)
    print("put(3, 3)  # Evicts 2")
    result13 = cache5.get(2)
    print(f"get(2) = {result13}")
    print("Expected: -1")
    print(f"âœ… PASS" if result13 == -1 else "âŒ FAIL")

    # Test Case 6: Large capacity
    print("\nğŸ“ Test Case 6: Larger capacity (capacity=5)")
    print("-" * 80)
    cache6 = LRUCache(5)
    for i in range(1, 6):
        cache6.put(i, i * 10)
    print("put(1,10), put(2,20), put(3,30), put(4,40), put(5,50)")

    cache6.get(3)
    cache6.get(5)
    print("get(3), get(5)  # 3 and 5 become MRU")

    cache6.put(6, 60)
    print("put(6, 60)  # Should evict 1 (LRU)")
    result14 = cache6.get(1)
    print(f"get(1) = {result14}")
    print("Expected: -1 (evicted)")
    print(f"âœ… PASS" if result14 == -1 else "âŒ FAIL")

    result15 = cache6.get(3)
    print(f"get(3) = {result15}")
    print("Expected: 30")
    print(f"âœ… PASS" if result15 == 30 else "âŒ FAIL")

    print("\n" + "="*80)
    print("              âœ… ALL TEST CASES COMPLETED!")
    print("="*80)


# ============================================================================
#              ğŸ“ LEARNING SUMMARY & KEY TAKEAWAYS
# ============================================================================

"""
ğŸ¯ WHAT YOU LEARNED:
-------------------
1. LRU Cache requires O(1) operations â†’ HashMap + DLL!
2. HashMap provides O(1) access to nodes
3. Doubly Linked List provides O(1) reordering
4. Dummy head/tail eliminate edge cases
5. Must update BOTH HashMap and DLL together!

ğŸ”‘ KEY PATTERN: "HashMap + Doubly Linked List"
-----------------------------------------------
This pattern applies when:
- Need O(1) access to elements
- Need O(1) insertion/deletion
- Need to maintain order
- Need to track "most/least recently used"

Used in:
- LRU Cache (this problem!)
- LFU Cache (LeetCode #460)
- All O(1) Data Structure (LeetCode #432)
- Browser back/forward buttons
- Operating system page replacement

ğŸ’ª THREE APPROACHES TO MASTER:
-----------------------------
1. HASHMAP + DLL (Optimal - O(1))
   - HashMap: key â†’ Node
   - DLL: head â†” ... â†” tail (MRU to LRU)
   - Dummy nodes eliminate edge cases
   - Industry standard implementation

2. ORDEREDDICT (Python - O(1))
   - Built-in Python data structure
   - Maintains insertion order
   - move_to_end() and popitem() are O(1)
   - Simpler but language-specific

3. ARRAY WITH TIMESTAMPS (Bad - O(N))
   - Shows WHY HashMap + DLL is needed
   - All operations become O(N)
   - Violates problem requirements
   - Educational only!

ğŸ¯ INTERVIEW TIPS:
-----------------
1. Clarify requirements:
   - Does get() count as "use"? (YES!)
   - Should put() existing key move to head? (YES!)
   - What to return if key doesn't exist? (-1)

2. Explain data structure choice:
   - HashMap alone can't track order
   - List alone can't find items in O(1)
   - DLL allows O(1) removal from anywhere
   - Dummy nodes simplify edge cases

3. Draw the structure:
   - Show HashMap and DLL together
   - Label MRU and LRU positions
   - Demonstrate pointer updates

4. Test edge cases:
   - Capacity of 1
   - Updating existing key
   - Multiple gets of same key
   - Empty cache

5. Mention real-world uses:
   - Web browser cache
   - Database query cache
   - CDN caching
   - OS memory management

ğŸ‰ CONGRATULATIONS!
------------------
You now understand how to implement LRU Cache with O(1) operations!
Remember: "HashMap finds it, Doubly Linked List orders it!"

ğŸ“Š COMPLEXITY SUMMARY:
---------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Approach           â”‚ Time         â”‚ Space        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ HashMap + DLL      â”‚ O(1)         â”‚ O(capacity)  â”‚
â”‚ OrderedDict        â”‚ O(1)         â”‚ O(capacity)  â”‚
â”‚ Array (Bad)        â”‚ O(N)         â”‚ O(capacity)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ† RECOMMENDED: Use HashMap + Doubly Linked List for optimal O(1) solution!

ğŸ”— RELATED PROBLEMS TO PRACTICE:
-------------------------------
1. LeetCode #146: LRU Cache (this problem!)
2. LeetCode #460: LFU Cache (Least Frequently Used)
3. LeetCode #432: All O(1) Data Structure
4. LeetCode #380: Insert Delete GetRandom O(1)
5. LeetCode #381: Insert Delete GetRandom O(1) - Duplicates allowed

ğŸ’¡ FINAL TIP:
------------
LRU Cache is one of the MOST IMPORTANT interview problems! It tests:
- Data structure knowledge (HashMap, Linked List)
- Pointer manipulation
- Edge case handling
- System design thinking

Master this problem thoroughly - it appears in 95% of system design interviews
at top tech companies! The pattern of "HashMap + DLL for O(1) operations"
is fundamental and appears in many other problems!
"""
